{
  "address": "0xA449635FaAA6b5a45a568fCe217Bb7921c992285",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "controllerGasLimit",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "CannotUpdateEmptyPosition",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC20TransferFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidHookResponse",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSqrtRatio",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidTick",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NativeTransferFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoLiquidityToReceiveFees",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PoolAlreadyInitialized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PoolNotInitialized",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint160",
          "name": "sqrtPriceCurrentX96",
          "type": "uint160"
        },
        {
          "internalType": "uint160",
          "name": "sqrtPriceLimitX96",
          "type": "uint160"
        }
      ],
      "name": "PriceLimitAlreadyExceeded",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint160",
          "name": "sqrtPriceLimitX96",
          "type": "uint160"
        }
      ],
      "name": "PriceLimitOutOfBounds",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SwapAmountCannotBeZero",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int24",
          "name": "tick",
          "type": "int24"
        }
      ],
      "name": "TickLiquidityOverflow",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        }
      ],
      "name": "TickLowerOutOfBounds",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int24",
          "name": "tick",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "tickSpacing",
          "type": "int24"
        }
      ],
      "name": "TickMisaligned",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        }
      ],
      "name": "TickUpperOutOfBounds",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        }
      ],
      "name": "TicksMisordered",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "ids",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "values",
          "type": "uint256[]"
        }
      ],
      "name": "TransferBatch",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "TransferSingle",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "value",
          "type": "string"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "URI",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "MAX_TICK_SPACING",
      "outputs": [
        {
          "internalType": "int24",
          "name": "",
          "type": "int24"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MIN_PROTOCOL_FEE_DENOMINATOR",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "accounts",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "ids",
          "type": "uint256[]"
        }
      ],
      "name": "balanceOfBatch",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "Currency",
          "name": "currency",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "collectHookFees",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountCollected",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "Currency",
          "name": "currency",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "collectProtocolFees",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountCollected",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "locker",
          "type": "address"
        },
        {
          "internalType": "Currency",
          "name": "currency",
          "type": "address"
        }
      ],
      "name": "currencyDelta",
      "outputs": [
        {
          "internalType": "int256",
          "name": "currencyDelta",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "Currency",
              "name": "currency0",
              "type": "address"
            },
            {
              "internalType": "Currency",
              "name": "currency1",
              "type": "address"
            },
            {
              "internalType": "uint24",
              "name": "fee",
              "type": "uint24"
            },
            {
              "internalType": "int24",
              "name": "tickSpacing",
              "type": "int24"
            },
            {
              "internalType": "contract IHooks",
              "name": "hooks",
              "type": "address"
            }
          ],
          "internalType": "struct PoolKey",
          "name": "key",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "amount0",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount1",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "hookData",
          "type": "bytes"
        }
      ],
      "name": "donate",
      "outputs": [
        {
          "internalType": "BalanceDelta",
          "name": "delta",
          "type": "int256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "slot",
          "type": "bytes32"
        }
      ],
      "name": "extsload",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "value",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "PoolId",
          "name": "id",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        }
      ],
      "name": "getLiquidity",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "liquidity",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "PoolId",
          "name": "id",
          "type": "bytes32"
        }
      ],
      "name": "getLiquidity",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "liquidity",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "i",
          "type": "uint256"
        }
      ],
      "name": "getLock",
      "outputs": [
        {
          "internalType": "address",
          "name": "locker",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "PoolId",
          "name": "id",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        }
      ],
      "name": "getPosition",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint128",
              "name": "liquidity",
              "type": "uint128"
            },
            {
              "internalType": "uint256",
              "name": "feeGrowthInside0LastX128",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "feeGrowthInside1LastX128",
              "type": "uint256"
            }
          ],
          "internalType": "struct Position.Info",
          "name": "position",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "PoolId",
          "name": "id",
          "type": "bytes32"
        }
      ],
      "name": "getSlot0",
      "outputs": [
        {
          "internalType": "uint160",
          "name": "sqrtPriceX96",
          "type": "uint160"
        },
        {
          "internalType": "int24",
          "name": "tick",
          "type": "int24"
        },
        {
          "internalType": "uint24",
          "name": "protocolFees",
          "type": "uint24"
        },
        {
          "internalType": "uint24",
          "name": "hookFees",
          "type": "uint24"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "hookAddress",
          "type": "address"
        },
        {
          "internalType": "Currency",
          "name": "currency",
          "type": "address"
        }
      ],
      "name": "hookFeesAccrued",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "Currency",
              "name": "currency0",
              "type": "address"
            },
            {
              "internalType": "Currency",
              "name": "currency1",
              "type": "address"
            },
            {
              "internalType": "uint24",
              "name": "fee",
              "type": "uint24"
            },
            {
              "internalType": "int24",
              "name": "tickSpacing",
              "type": "int24"
            },
            {
              "internalType": "contract IHooks",
              "name": "hooks",
              "type": "address"
            }
          ],
          "internalType": "struct PoolKey",
          "name": "key",
          "type": "tuple"
        },
        {
          "internalType": "uint160",
          "name": "sqrtPriceX96",
          "type": "uint160"
        },
        {
          "internalType": "bytes",
          "name": "hookData",
          "type": "bytes"
        }
      ],
      "name": "initialize",
      "outputs": [
        {
          "internalType": "int24",
          "name": "tick",
          "type": "int24"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "lock",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "result",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lockData",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "length",
          "type": "uint128"
        },
        {
          "internalType": "uint128",
          "name": "nonzeroDeltaCount",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "Currency",
          "name": "currency",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "mint",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "Currency",
              "name": "currency0",
              "type": "address"
            },
            {
              "internalType": "Currency",
              "name": "currency1",
              "type": "address"
            },
            {
              "internalType": "uint24",
              "name": "fee",
              "type": "uint24"
            },
            {
              "internalType": "int24",
              "name": "tickSpacing",
              "type": "int24"
            },
            {
              "internalType": "contract IHooks",
              "name": "hooks",
              "type": "address"
            }
          ],
          "internalType": "struct PoolKey",
          "name": "key",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "int24",
              "name": "tickLower",
              "type": "int24"
            },
            {
              "internalType": "int24",
              "name": "tickUpper",
              "type": "int24"
            },
            {
              "internalType": "int256",
              "name": "liquidityDelta",
              "type": "int256"
            }
          ],
          "internalType": "struct IPoolManager.ModifyPositionParams",
          "name": "params",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "hookData",
          "type": "bytes"
        }
      ],
      "name": "modifyPosition",
      "outputs": [
        {
          "internalType": "BalanceDelta",
          "name": "delta",
          "type": "int256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onERC1155Received",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "PoolId",
          "name": "id",
          "type": "bytes32"
        }
      ],
      "name": "pools",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint160",
              "name": "sqrtPriceX96",
              "type": "uint160"
            },
            {
              "internalType": "int24",
              "name": "tick",
              "type": "int24"
            },
            {
              "internalType": "uint24",
              "name": "protocolFees",
              "type": "uint24"
            },
            {
              "internalType": "uint24",
              "name": "hookFees",
              "type": "uint24"
            }
          ],
          "internalType": "struct Pool.Slot0",
          "name": "slot0",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "feeGrowthGlobal0X128",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "feeGrowthGlobal1X128",
          "type": "uint256"
        },
        {
          "internalType": "uint128",
          "name": "liquidity",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "protocolFeeController",
      "outputs": [
        {
          "internalType": "contract IProtocolFeeController",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "Currency",
          "name": "currency",
          "type": "address"
        }
      ],
      "name": "protocolFeesAccrued",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "Currency",
          "name": "currency",
          "type": "address"
        }
      ],
      "name": "reservesOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "Currency",
              "name": "currency0",
              "type": "address"
            },
            {
              "internalType": "Currency",
              "name": "currency1",
              "type": "address"
            },
            {
              "internalType": "uint24",
              "name": "fee",
              "type": "uint24"
            },
            {
              "internalType": "int24",
              "name": "tickSpacing",
              "type": "int24"
            },
            {
              "internalType": "contract IHooks",
              "name": "hooks",
              "type": "address"
            }
          ],
          "internalType": "struct PoolKey",
          "name": "key",
          "type": "tuple"
        }
      ],
      "name": "setHookFees",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IProtocolFeeController",
          "name": "controller",
          "type": "address"
        }
      ],
      "name": "setProtocolFeeController",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "Currency",
              "name": "currency0",
              "type": "address"
            },
            {
              "internalType": "Currency",
              "name": "currency1",
              "type": "address"
            },
            {
              "internalType": "uint24",
              "name": "fee",
              "type": "uint24"
            },
            {
              "internalType": "int24",
              "name": "tickSpacing",
              "type": "int24"
            },
            {
              "internalType": "contract IHooks",
              "name": "hooks",
              "type": "address"
            }
          ],
          "internalType": "struct PoolKey",
          "name": "key",
          "type": "tuple"
        }
      ],
      "name": "setProtocolFees",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "Currency",
          "name": "currency",
          "type": "address"
        }
      ],
      "name": "settle",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "paid",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "Currency",
              "name": "currency0",
              "type": "address"
            },
            {
              "internalType": "Currency",
              "name": "currency1",
              "type": "address"
            },
            {
              "internalType": "uint24",
              "name": "fee",
              "type": "uint24"
            },
            {
              "internalType": "int24",
              "name": "tickSpacing",
              "type": "int24"
            },
            {
              "internalType": "contract IHooks",
              "name": "hooks",
              "type": "address"
            }
          ],
          "internalType": "struct PoolKey",
          "name": "key",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "bool",
              "name": "zeroForOne",
              "type": "bool"
            },
            {
              "internalType": "int256",
              "name": "amountSpecified",
              "type": "int256"
            },
            {
              "internalType": "uint160",
              "name": "sqrtPriceLimitX96",
              "type": "uint160"
            }
          ],
          "internalType": "struct IPoolManager.SwapParams",
          "name": "params",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "hookData",
          "type": "bytes"
        }
      ],
      "name": "swap",
      "outputs": [
        {
          "internalType": "BalanceDelta",
          "name": "delta",
          "type": "int256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "Currency",
          "name": "currency",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "take",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "uri",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x96ecd7a4daaf79ae4bbd6bcffdc752724ab0d18006ec476b22e91d21cc54d7f5",
  "receipt": {
    "to": null,
    "from": "0x19d96301865fdD07427db3c445508A051BC6D352",
    "contractAddress": "0xA449635FaAA6b5a45a568fCe217Bb7921c992285",
    "transactionIndex": 0,
    "gasUsed": "5322183",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x345bd9bcf3a5470fdf99402e35af03328583663cdbe320ed0f0bae01015b82f4",
    "transactionHash": "0x96ecd7a4daaf79ae4bbd6bcffdc752724ab0d18006ec476b22e91d21cc54d7f5",
    "logs": [],
    "blockNumber": 1013107,
    "cumulativeGasUsed": "5322183",
    "status": 1,
    "byzantium": true
  },
  "args": [
    500000
  ],
  "numDeployments": 1,
  "solcInputHash": "f3c68a0f4f373e9616959b1df272a27b",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"controllerGasLimit\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CannotUpdateEmptyPosition\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidHookResponse\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSqrtRatio\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTick\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoLiquidityToReceiveFees\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolAlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolNotInitialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceCurrentX96\",\"type\":\"uint160\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"name\":\"PriceLimitAlreadyExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"name\":\"PriceLimitOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SwapAmountCannotBeZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"}],\"name\":\"TickLiquidityOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"}],\"name\":\"TickLowerOutOfBounds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"}],\"name\":\"TickMisaligned\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"TickUpperOutOfBounds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"TicksMisordered\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_TICK_SPACING\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_PROTOCOL_FEE_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"collectHookFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountCollected\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"collectProtocolFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountCollected\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"currencyDelta\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"currencyDelta\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contract IHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"struct PoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"donate\",\"outputs\":[{\"internalType\":\"BalanceDelta\",\"name\":\"delta\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"}],\"name\":\"extsload\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"value\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"getLiquidity\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getLiquidity\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getLock\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"getPosition\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthInside0LastX128\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthInside1LastX128\",\"type\":\"uint256\"}],\"internalType\":\"struct Position.Info\",\"name\":\"position\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getSlot0\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"},{\"internalType\":\"uint24\",\"name\":\"protocolFees\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"hookFees\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hookAddress\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"hookFeesAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contract IHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"struct PoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"lock\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockData\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"length\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"nonzeroDeltaCount\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Currency\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contract IHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"struct PoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"}],\"internalType\":\"struct IPoolManager.ModifyPositionParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"modifyPosition\",\"outputs\":[{\"internalType\":\"BalanceDelta\",\"name\":\"delta\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"pools\",\"outputs\":[{\"components\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"},{\"internalType\":\"uint24\",\"name\":\"protocolFees\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"hookFees\",\"type\":\"uint24\"}],\"internalType\":\"struct Pool.Slot0\",\"name\":\"slot0\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthGlobal0X128\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthGlobal1X128\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeeController\",\"outputs\":[{\"internalType\":\"contract IProtocolFeeController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Currency\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"protocolFeesAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Currency\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"reservesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contract IHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"struct PoolKey\",\"name\":\"key\",\"type\":\"tuple\"}],\"name\":\"setHookFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IProtocolFeeController\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"setProtocolFeeController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contract IHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"struct PoolKey\",\"name\":\"key\",\"type\":\"tuple\"}],\"name\":\"setProtocolFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Currency\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"settle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contract IHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"struct PoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"struct IPoolManager.SwapParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"BalanceDelta\",\"name\":\"delta\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Currency\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"take\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"errors\":{\"PriceLimitAlreadyExceeded(uint160,uint160)\":[{\"params\":{\"sqrtPriceCurrentX96\":\"The invalid, already surpassed sqrtPriceLimitX96\",\"sqrtPriceLimitX96\":\"The surpassed price limit\"}}],\"PriceLimitOutOfBounds(uint160)\":[{\"params\":{\"sqrtPriceLimitX96\":\"The invalid, out-of-bounds sqrtPriceLimitX96\"}}],\"TickLowerOutOfBounds(int24)\":[{\"params\":{\"tickLower\":\"The invalid tickLower\"}}],\"TickMisaligned(int24,int24)\":[{\"params\":{\"tick\":\"the invalid tick\",\"tickSpacing\":\"The tick spacing of the pool\"}}],\"TickUpperOutOfBounds(int24)\":[{\"params\":{\"tickUpper\":\"The invalid tickUpper\"}}],\"TicksMisordered(int24,int24)\":[{\"params\":{\"tickLower\":\"The invalid tickLower\",\"tickUpper\":\"The invalid tickUpper\"}}]},\"events\":{\"ApprovalForAll(address,address,bool)\":{\"details\":\"Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to `approved`.\"},\"TransferBatch(address,address,address,uint256[],uint256[])\":{\"details\":\"Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all transfers.\"},\"TransferSingle(address,address,address,uint256,uint256)\":{\"details\":\"Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\"},\"URI(string,uint256)\":{\"details\":\"Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI. If an {URI} event was emitted for `id`, the standard https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value returned by {IERC1155MetadataURI-uri}.\"}},\"kind\":\"dev\",\"methods\":{\"balanceOf(address,uint256)\":{\"details\":\"See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.\"},\"balanceOfBatch(address[],uint256[])\":{\"details\":\"See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.\"},\"extsload(bytes32)\":{\"params\":{\"slot\":\"Key of slot to sload\"},\"returns\":{\"value\":\"The value of the slot as bytes32\"}},\"isApprovedForAll(address,address)\":{\"details\":\"See {IERC1155-isApprovedForAll}.\"},\"lock(bytes)\":{\"params\":{\"data\":\"Any data to pass to the callback, via `ILockCallback(msg.sender).lockCallback(data)`\"},\"returns\":{\"result\":\"The data returned by the call to `ILockCallback(msg.sender).lockCallback(data)`\"}},\"safeTransferFrom(address,address,uint256,uint256,bytes)\":{\"details\":\"See {IERC1155-safeTransferFrom}.\"},\"setApprovalForAll(address,bool)\":{\"details\":\"See {IERC1155-setApprovalForAll}.\"},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"},\"take(address,address,uint256)\":{\"details\":\"Can also be used as a mechanism for _free_ flash loans\"},\"uri(uint256)\":{\"details\":\"See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\\\\{id\\\\}` substring with the actual token type ID.\"}},\"stateVariables\":{\"currencyDelta\":{\"details\":\"Represents the currencies due/owed to each locker. Must all net to zero when the last lock is released.\"}},\"version\":1},\"userdoc\":{\"errors\":{\"CannotUpdateEmptyPosition()\":[{\"notice\":\"Cannot update a position with no liquidity\"}],\"ERC20TransferFailed()\":[{\"notice\":\"Thrown when an ERC20 transfer fails\"}],\"InvalidHookResponse()\":[{\"notice\":\"Hook did not return its selector\"}],\"InvalidSqrtRatio()\":[{\"notice\":\"Thrown when the ratio passed to #getTickAtSqrtRatio does not correspond to a price between MIN_TICK and MAX_TICK\"}],\"InvalidTick()\":[{\"notice\":\"Thrown when the tick passed to #getSqrtRatioAtTick is not between MIN_TICK and MAX_TICK\"}],\"NativeTransferFailed()\":[{\"notice\":\"Thrown when a native transfer fails\"}],\"NoLiquidityToReceiveFees()\":[{\"notice\":\"Thrown by donate if there is currently 0 liquidity, since the fees will not go to any liquidity providers\"}],\"PoolAlreadyInitialized()\":[{\"notice\":\"Thrown when trying to initalize an already initialized pool\"}],\"PoolNotInitialized()\":[{\"notice\":\"Thrown when trying to interact with a non-initialized pool\"}],\"PriceLimitAlreadyExceeded(uint160,uint160)\":[{\"notice\":\"Thrown when sqrtPriceLimitX96 on a swap has already exceeded its limit\"}],\"PriceLimitOutOfBounds(uint160)\":[{\"notice\":\"Thrown when sqrtPriceLimitX96 lies outside of valid tick/price range\"}],\"SwapAmountCannotBeZero()\":[{\"notice\":\"Thrown when trying to swap amount of 0\"}],\"TickLiquidityOverflow(int24)\":[{\"notice\":\"For the tick spacing, the tick has too much liquidity\"}],\"TickLowerOutOfBounds(int24)\":[{\"notice\":\"Thrown when tickLower is less than min tick\"}],\"TickMisaligned(int24,int24)\":[{\"notice\":\"Thrown when the tick is not enumerated by the tick spacing\"}],\"TickUpperOutOfBounds(int24)\":[{\"notice\":\"Thrown when tickUpper exceeds max tick\"}],\"TicksMisordered(int24,int24)\":[{\"notice\":\"Thrown when tickLower is not below tickUpper\"}]},\"kind\":\"user\",\"methods\":{\"MAX_TICK_SPACING()\":{\"notice\":\"Returns the constant representing the maximum tickSpacing for an initialized pool key\"},\"MIN_PROTOCOL_FEE_DENOMINATOR()\":{\"notice\":\"Returns the minimum denominator for the protocol fee, which restricts it to a maximum of 25%\"},\"donate((address,address,uint24,int24,address),uint256,uint256,bytes)\":{\"notice\":\"Donate the given currency amounts to the pool with the given pool key\"},\"extsload(bytes32)\":{\"notice\":\"Called by external contracts to access granular pool state\"},\"getLiquidity(bytes32)\":{\"notice\":\"Get the current value of liquidity of the given pool\"},\"getLiquidity(bytes32,address,int24,int24)\":{\"notice\":\"Get the current value of liquidity for the specified pool and position\"},\"getLock(uint256)\":{\"notice\":\"Returns the locker in the ith position of the locker queue.\"},\"getPosition(bytes32,address,int24,int24)\":{\"notice\":\"Get the position struct for a specified pool and position\"},\"getSlot0(bytes32)\":{\"notice\":\"Get the current value in slot0 of the given pool\"},\"hookFeesAccrued(address,address)\":{\"notice\":\"Given a hook and a currency address, returns the fees accrued\"},\"initialize((address,address,uint24,int24,address),uint160,bytes)\":{\"notice\":\"Initialize the state for a given pool ID\"},\"lock(bytes)\":{\"notice\":\"All operations go through this function\"},\"lockData()\":{\"notice\":\"Returns lock data\"},\"mint(address,address,uint256)\":{\"notice\":\"Called by the user to move value into ERC1155 balance\"},\"modifyPosition((address,address,uint24,int24,address),(int24,int24,int256),bytes)\":{\"notice\":\"Modify the position for the given pool\"},\"protocolFeesAccrued(address)\":{\"notice\":\"Given a currency address, returns the protocol fees accrued in that currency\"},\"reservesOf(address)\":{\"notice\":\"Returns the reserves for a given ERC20 currency\"},\"setHookFees((address,address,uint24,int24,address))\":{\"notice\":\"Sets the hook's swap and withdrawal fees for the given pool\"},\"setProtocolFees((address,address,uint24,int24,address))\":{\"notice\":\"Sets the protocol's swap and withdrawal fees for the given pool Protocol fees are always a portion of a fee that is owed. If that underlying fee is 0, no protocol fees will accrue even if it is set to > 0.\"},\"settle(address)\":{\"notice\":\"Called by the user to pay what is owed\"},\"swap((address,address,uint24,int24,address),(bool,int256,uint160),bytes)\":{\"notice\":\"Swap against the given pool\"},\"take(address,address,uint256)\":{\"notice\":\"Called by the user to net out some value owed to the user\"}},\"notice\":\"Holds the state for all pools\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"@uniswap/v4-core/contracts/PoolManager.sol\":\"PoolManager\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/ERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURI.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor(string memory uri_) {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(\\n        address account,\\n        uint256 id\\n    ) public view virtual override returns (uint256) {\\n        require(\\n            account != address(0),\\n            \\\"ERC1155: address zero is not a valid owner\\\"\\n        );\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    ) public view virtual override returns (uint256[] memory) {\\n        require(\\n            accounts.length == ids.length,\\n            \\\"ERC1155: accounts and ids length mismatch\\\"\\n        );\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(\\n        address operator,\\n        bool approved\\n    ) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(\\n        address account,\\n        address operator\\n    ) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    // function safeBatchTransferFrom(\\n    //     address from,\\n    //     address to,\\n    //     uint256[] memory ids,\\n    //     uint256[] memory amounts,\\n    //     bytes memory data\\n    // ) public virtual override {\\n    //     require(\\n    //         from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n    //         \\\"ERC1155: caller is not token owner or approved\\\"\\n    //     );\\n    //     _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    // }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(\\n            fromBalance >= amount,\\n            \\\"ERC1155: insufficient balance for transfer\\\"\\n        );\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    // /**\\n    //  * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n    //  *\\n    //  * Emits a {TransferBatch} event.\\n    //  *\\n    //  * Requirements:\\n    //  *\\n    //  * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n    //  * acceptance magic value.\\n    //  */\\n    // function _safeBatchTransferFrom(\\n    //     address from,\\n    //     address to,\\n    //     uint256[] memory ids,\\n    //     uint256[] memory amounts,\\n    //     bytes memory data\\n    // ) internal virtual {\\n    //     require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n    //     require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n    //     address operator = _msgSender();\\n\\n    //     _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n    //     for (uint256 i = 0; i < ids.length; ++i) {\\n    //         uint256 id = ids[i];\\n    //         uint256 amount = amounts[i];\\n\\n    //         uint256 fromBalance = _balances[id][from];\\n    //         require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n    //         unchecked {\\n    //             _balances[id][from] = fromBalance - amount;\\n    //         }\\n    //         _balances[id][to] += amount;\\n    //     }\\n\\n    //     emit TransferBatch(operator, from, to, ids, amounts);\\n\\n    //     _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n    //     _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    // }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _balances[id][to] += amount;\\n        emit TransferSingle(operator, address(0), to, id, amount);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(\\n            operator,\\n            address(0),\\n            to,\\n            id,\\n            amount,\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    // function _mintBatch(\\n    //     address to,\\n    //     uint256[] memory ids,\\n    //     uint256[] memory amounts,\\n    //     bytes memory data\\n    // ) internal virtual {\\n    //     require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n    //     require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n    //     address operator = _msgSender();\\n\\n    //     _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n    //     for (uint256 i = 0; i < ids.length; i++) {\\n    //         _balances[ids[i]][to] += amounts[i];\\n    //     }\\n\\n    //     emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n    //     _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n    //     _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    // }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, from, address(0), id, amount);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(\\n            ids.length == amounts.length,\\n            \\\"ERC1155: ids and amounts length mismatch\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(\\n                fromBalance >= amount,\\n                \\\"ERC1155: burn amount exceeds balance\\\"\\n            );\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC1155: setting approval status for self\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try\\n                IERC1155Receiver(to).onERC1155Received(\\n                    operator,\\n                    from,\\n                    id,\\n                    amount,\\n                    data\\n                )\\n            returns (bytes4 response) {\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    // function _doSafeBatchTransferAcceptanceCheck(\\n    //     address operator,\\n    //     address from,\\n    //     address to,\\n    //     uint256[] memory ids,\\n    //     uint256[] memory amounts,\\n    //     bytes memory data\\n    // ) private {\\n    //     if (to.isContract()) {\\n    //         try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n    //             bytes4 response\\n    //         ) {\\n    //             if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\n    //                 revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n    //             }\\n    //         } catch Error(string memory reason) {\\n    //             revert(reason);\\n    //         } catch {\\n    //             revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\n    //         }\\n    //     }\\n    // }\\n\\n    function _asSingletonArray(\\n        uint256 element\\n    ) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\",\"keccak256\":\"0x2b8d9790b6f4dae48d3de3caef142be99e3e98bb140bacd8524a7111e347d0cf\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 value\\n    );\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(\\n        address indexed account,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(\\n        address account,\\n        uint256 id\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(\\n        address account,\\n        address operator\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    // function safeBatchTransferFrom(\\n    //     address from,\\n    //     address to,\\n    //     uint256[] calldata ids,\\n    //     uint256[] calldata amounts,\\n    //     bytes calldata data\\n    // ) external;\\n}\\n\",\"keccak256\":\"0xc0d8dee6f50d5b2aefe3d769d06108ed65f4ce53c881ba5891e14ec464457b2e\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    // function onERC1155BatchReceived(\\n    //     address operator,\\n    //     address from,\\n    //     uint256[] calldata ids,\\n    //     uint256[] calldata values,\\n    //     bytes calldata data\\n    // ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xf85fd7796731c35a3b08f88ddcbf36baf4f176a79687df863d5083fae5c9ce7d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xa66d18b9a85458d28fc3304717964502ae36f7f8a2ff35bc83f6f85d74b03574\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@uniswap/v4-core/contracts/Fees.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.19;\\n\\nimport {Currency, CurrencyLibrary} from './types/Currency.sol';\\nimport {IProtocolFeeController} from './interfaces/IProtocolFeeController.sol';\\nimport {IHookFeeManager} from './interfaces/IHookFeeManager.sol';\\nimport {IFees} from './interfaces/IFees.sol';\\nimport {FeeLibrary} from './libraries/FeeLibrary.sol';\\nimport {Pool} from './libraries/Pool.sol';\\nimport {PoolKey} from './types/PoolKey.sol';\\n\\n//import {Owned} from './Owned.sol';\\n\\nabstract contract Fees is IFees {\\n    using FeeLibrary for uint24;\\n    using CurrencyLibrary for Currency;\\n\\n    uint8 public constant MIN_PROTOCOL_FEE_DENOMINATOR = 4;\\n\\n    mapping(Currency currency => uint256) public protocolFeesAccrued;\\n\\n    mapping(address hookAddress => mapping(Currency currency => uint256)) public hookFeesAccrued;\\n\\n    IProtocolFeeController public protocolFeeController;\\n\\n    uint256 private immutable controllerGasLimit;\\n\\n    constructor(uint256 _controllerGasLimit) {\\n        controllerGasLimit = _controllerGasLimit;\\n    }\\n\\n    function _fetchProtocolFees(PoolKey memory key) internal view returns (uint24 protocolFees) {\\n        uint16 protocolSwapFee;\\n        uint16 protocolWithdrawFee;\\n        if (address(protocolFeeController) != address(0)) {\\n            // note that EIP-150 mandates that calls requesting more than 63/64ths of remaining gas\\n            // will be allotted no more than this amount, so controllerGasLimit must be set with this\\n            // in mind.\\n            if (gasleft() < controllerGasLimit) revert();\\n            try protocolFeeController.protocolFeesForPool{gas: controllerGasLimit}(key) returns (\\n                uint24 updatedProtocolFees\\n            ) {\\n                protocolSwapFee = uint16(updatedProtocolFees >> 12);\\n                protocolWithdrawFee = uint16(updatedProtocolFees & 0xFFF);\\n\\n                protocolFees = updatedProtocolFees;\\n            } catch {}\\n            _checkProtocolFee(protocolSwapFee);\\n            _checkProtocolFee(protocolWithdrawFee);\\n        }\\n    }\\n\\n    /// @notice There is no cap on the hook fee, but it is specified as a percentage taken on the amount after the protocol fee is applied, if there is a protocol fee.\\n    function _fetchHookFees(PoolKey memory key) internal view returns (uint24 hookFees) {\\n        if (address(key.hooks) != address(0)) {\\n            try IHookFeeManager(address(key.hooks)).getHookFees(key) returns (uint24 hookFeesRaw) {\\n                uint24 swapFeeMask = key.fee.hasHookSwapFee() ? 0xFFF000 : 0;\\n                uint24 withdrawFeeMask = key.fee.hasHookWithdrawFee() ? 0xFFF : 0;\\n                uint24 fullFeeMask = swapFeeMask | withdrawFeeMask;\\n                hookFees = hookFeesRaw & fullFeeMask;\\n            } catch {}\\n        }\\n    }\\n\\n    /// @dev Only the lower 12 bits are used here to encode the fee denominator.\\n    function _checkProtocolFee(uint16 fee) internal pure {\\n        if (fee != 0) {\\n            uint16 fee0 = fee % 64;\\n            uint16 fee1 = fee >> 6;\\n            // The fee is specified as a denominator so it cannot be LESS than the MIN_PROTOCOL_FEE_DENOMINATOR (unless it is 0).\\n            if (\\n                (fee0 != 0 && fee0 < MIN_PROTOCOL_FEE_DENOMINATOR) || (fee1 != 0 && fee1 < MIN_PROTOCOL_FEE_DENOMINATOR)\\n            ) {\\n                revert();\\n            }\\n        }\\n    }\\n\\n    function setProtocolFeeController(IProtocolFeeController controller) external {\\n        protocolFeeController = controller;\\n        //emit ProtocolFeeControllerUpdated(address(controller));\\n    }\\n\\n    function collectProtocolFees(\\n        address recipient,\\n        Currency currency,\\n        uint256 amount\\n    ) external returns (uint256 amountCollected) {\\n        //if (msg.sender != owner && msg.sender != address(protocolFeeController)) revert InvalidCaller();\\n\\n        amountCollected = (amount == 0) ? protocolFeesAccrued[currency] : amount;\\n        protocolFeesAccrued[currency] -= amountCollected;\\n        currency.transfer(recipient, amountCollected);\\n    }\\n\\n    function collectHookFees(\\n        address recipient,\\n        Currency currency,\\n        uint256 amount\\n    ) external returns (uint256 amountCollected) {\\n        address hookAddress = msg.sender;\\n\\n        amountCollected = (amount == 0) ? hookFeesAccrued[hookAddress][currency] : amount;\\n        recipient = (recipient == address(0)) ? hookAddress : recipient;\\n\\n        hookFeesAccrued[hookAddress][currency] -= amountCollected;\\n        currency.transfer(recipient, amountCollected);\\n    }\\n}\\n\",\"keccak256\":\"0x0cb8cac15e55f4e2410ce5ae23af78d5a12c15d068550ccb034cd96228324339\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/Owned.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.20;\\n\\ncontract Owned {\\n    address public owner;\\n    bytes12 private STORAGE_PLACEHOLDER;\\n\\n    error InvalidCaller();\\n\\n    /// @notice Emitted when the owner of the factory is changed\\n    /// @param oldOwner The owner before the owner was changed\\n    /// @param newOwner The owner after the owner was changed\\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n\\n    modifier onlyOwner() {\\n        if (msg.sender != owner) revert InvalidCaller();\\n        _;\\n    }\\n\\n    constructor() {\\n        owner = msg.sender;\\n        emit OwnerChanged(address(0), msg.sender);\\n    }\\n\\n    function setOwner(address _owner) external onlyOwner {\\n        emit OwnerChanged(owner, _owner);\\n        owner = _owner;\\n    }\\n}\\n\",\"keccak256\":\"0x0109d375f0df894818365069e711e88bb8b6b315a867cac951f22bafeedacd64\",\"license\":\"BUSL-1.1\"},\"@uniswap/v4-core/contracts/PoolManager.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.20;\\n\\nimport {Hooks} from './libraries/Hooks.sol';\\nimport {Pool} from './libraries/Pool.sol';\\nimport {SafeCast} from './libraries/SafeCast.sol';\\nimport {Position} from './libraries/Position.sol';\\nimport {FeeLibrary} from './libraries/FeeLibrary.sol';\\nimport {Currency, CurrencyLibrary} from './types/Currency.sol';\\nimport {PoolKey} from './types/PoolKey.sol';\\nimport {LockDataLibrary} from './libraries/LockDataLibrary.sol';\\n//import {NoDelegateCall} from './NoDelegateCall.sol';\\nimport {Owned} from './Owned.sol';\\nimport {IHooks} from './interfaces/IHooks.sol';\\nimport {IDynamicFeeManager} from './interfaces/IDynamicFeeManager.sol';\\nimport {IHookFeeManager} from './interfaces/IHookFeeManager.sol';\\nimport {IPoolManager} from './interfaces/IPoolManager.sol';\\nimport {ILockCallback} from './interfaces/callback/ILockCallback.sol';\\nimport {Fees} from './Fees.sol';\\nimport {ERC1155} from '@openzeppelin/contracts/token/ERC1155/ERC1155.sol';\\nimport {IERC1155Receiver} from '@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol';\\nimport {PoolId, PoolIdLibrary} from './types/PoolId.sol';\\nimport {BalanceDelta} from './types/BalanceDelta.sol';\\nimport 'hardhat/console.sol';\\n\\n/// @notice Holds the state for all pools\\ncontract PoolManager is IPoolManager, Fees, ERC1155, IERC1155Receiver {\\n    using PoolIdLibrary for PoolKey;\\n    using SafeCast for *;\\n    using Pool for *;\\n    using Hooks for IHooks;\\n    using Position for mapping(bytes32 => Position.Info);\\n    using CurrencyLibrary for Currency;\\n    using LockDataLibrary for IPoolManager.LockData;\\n    using FeeLibrary for uint24;\\n\\n    /// @inheritdoc IPoolManager\\n    int24 public constant override MAX_TICK_SPACING = type(int16).max;\\n\\n    /// @inheritdoc IPoolManager\\n    // int24 public constant override MIN_TICK_SPACING = 1;\\n\\n    /// @inheritdoc IPoolManager\\n    IPoolManager.LockData public override lockData;\\n\\n    /// @dev Represents the currencies due/owed to each locker.\\n    /// Must all net to zero when the last lock is released.\\n    mapping(address locker => mapping(Currency currency => int256 currencyDelta)) public currencyDelta;\\n\\n    /// @inheritdoc IPoolManager\\n    mapping(Currency currency => uint256) public override reservesOf;\\n\\n    mapping(PoolId id => Pool.State) public pools;\\n\\n    constructor(uint256 controllerGasLimit) Fees(controllerGasLimit) ERC1155('') {}\\n\\n    function _getPool(PoolKey memory key) private view returns (Pool.State storage) {\\n        return pools[key.toId()];\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function getSlot0(\\n        PoolId id\\n    ) external view override returns (uint160 sqrtPriceX96, int24 tick, uint24 protocolFees, uint24 hookFees) {\\n        Pool.Slot0 memory slot0 = pools[id].slot0;\\n\\n        return (slot0.sqrtPriceX96, slot0.tick, slot0.protocolFees, slot0.hookFees);\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function getLiquidity(PoolId id) external view override returns (uint128 liquidity) {\\n        return pools[id].liquidity;\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function getLiquidity(\\n        PoolId id,\\n        address _owner,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) external view override returns (uint128 liquidity) {\\n        return pools[id].positions.get(_owner, tickLower, tickUpper).liquidity;\\n    }\\n\\n    function getPosition(\\n        PoolId id,\\n        address owner,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) external view override returns (Position.Info memory position) {\\n        return pools[id].positions.get(owner, tickLower, tickUpper);\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function getLock(uint256 i) external view override returns (address locker) {\\n        return LockDataLibrary.getLock(i);\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function initialize(\\n        PoolKey memory key,\\n        uint160 sqrtPriceX96,\\n        bytes calldata hookData\\n    ) external override returns (int24 tick) {\\n        if (key.fee.isStaticFeeTooLarge()) revert();\\n\\n        // see TickBitmap.sol for overflow conditions that can arise from tick spacing being too large\\n        if (key.tickSpacing > MAX_TICK_SPACING) revert();\\n        // if (key.tickSpacing < MIN_TICK_SPACING) revert();\\n        if (key.currency0 > key.currency1) revert();\\n        if (!key.hooks.isValidHookAddress(key.fee)) revert();\\n\\n        if (key.hooks.shouldCallBeforeInitialize()) {\\n            if (\\n                key.hooks.beforeInitialize(msg.sender, key, sqrtPriceX96, hookData) != IHooks.beforeInitialize.selector\\n            ) {\\n                revert Hooks.InvalidHookResponse();\\n            }\\n        }\\n\\n        PoolId id = key.toId();\\n        uint24 protocolFees = _fetchProtocolFees(key);\\n        uint24 hookFees = _fetchHookFees(key);\\n        tick = pools[id].initialize(sqrtPriceX96, protocolFees, hookFees);\\n\\n        if (key.hooks.shouldCallAfterInitialize()) {\\n            if (\\n                key.hooks.afterInitialize(msg.sender, key, sqrtPriceX96, tick, hookData) !=\\n                IHooks.afterInitialize.selector\\n            ) {\\n                revert Hooks.InvalidHookResponse();\\n            }\\n        }\\n\\n        // emit Initialize(id, key.currency0, key.currency1, key.fee, key.tickSpacing, key.hooks);\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function lock(bytes calldata data) external override returns (bytes memory result) {\\n        lockData.push(msg.sender);\\n\\n        // the caller does everything in this callback, including paying what they owe via calls to settle\\n        result = ILockCallback(msg.sender).lockAcquired(data);\\n\\n        if (lockData.length == 1) {\\n            if (lockData.nonzeroDeltaCount != 0) revert();\\n            delete lockData;\\n        } else {\\n            lockData.pop();\\n        }\\n    }\\n\\n    function _accountDelta(Currency currency, int128 delta) internal {\\n        if (delta == 0) return;\\n\\n        address locker = lockData.getActiveLock();\\n        int256 current = currencyDelta[locker][currency];\\n        int256 next = current + delta;\\n\\n        unchecked {\\n            if (next == 0) {\\n                lockData.nonzeroDeltaCount--;\\n            } else if (current == 0) {\\n                lockData.nonzeroDeltaCount++;\\n            }\\n        }\\n\\n        currencyDelta[locker][currency] = next;\\n    }\\n\\n    /// @dev Accumulates a balance change to a map of currency to balance changes\\n    function _accountPoolBalanceDelta(PoolKey memory key, BalanceDelta delta) internal {\\n        _accountDelta(key.currency0, delta.amount0());\\n        _accountDelta(key.currency1, delta.amount1());\\n    }\\n\\n    // modifier () {\\n    //     address locker = lockData.getActiveLock();\\n    //     if (msg.sender != locker) revert();\\n    //     _;\\n    // }\\n\\n    /// @inheritdoc IPoolManager\\n    function modifyPosition(\\n        PoolKey memory key,\\n        IPoolManager.ModifyPositionParams memory params,\\n        bytes calldata hookData\\n    ) external override returns (BalanceDelta delta) {\\n        if (key.hooks.shouldCallBeforeModifyPosition()) {\\n            if (\\n                key.hooks.beforeModifyPosition(msg.sender, key, params, hookData) !=\\n                IHooks.beforeModifyPosition.selector\\n            ) {\\n                revert();\\n            }\\n        }\\n        PoolId id = key.toId();\\n        Pool.FeeAmounts memory feeAmounts;\\n        (delta, feeAmounts) = pools[id].modifyPosition(\\n            Pool.ModifyPositionParams({\\n                owner: msg.sender,\\n                tickLower: params.tickLower,\\n                tickUpper: params.tickUpper,\\n                liquidityDelta: params.liquidityDelta.toInt128(),\\n                tickSpacing: key.tickSpacing\\n            })\\n        );\\n\\n        _accountPoolBalanceDelta(key, delta);\\n\\n        unchecked {\\n            if (feeAmounts.feeForProtocol0 > 0) {\\n                protocolFeesAccrued[key.currency0] += feeAmounts.feeForProtocol0;\\n            }\\n            if (feeAmounts.feeForProtocol1 > 0) {\\n                protocolFeesAccrued[key.currency1] += feeAmounts.feeForProtocol1;\\n            }\\n            if (feeAmounts.feeForHook0 > 0) {\\n                hookFeesAccrued[address(key.hooks)][key.currency0] += feeAmounts.feeForHook0;\\n            }\\n            if (feeAmounts.feeForHook1 > 0) {\\n                hookFeesAccrued[address(key.hooks)][key.currency1] += feeAmounts.feeForHook1;\\n            }\\n        }\\n\\n        if (key.hooks.shouldCallAfterModifyPosition()) {\\n            if (\\n                key.hooks.afterModifyPosition(msg.sender, key, params, delta, hookData) !=\\n                IHooks.afterModifyPosition.selector\\n            ) {\\n                revert();\\n            }\\n        }\\n\\n        // emit ModifyPosition(id, msg.sender, params.tickLower, params.tickUpper, params.liquidityDelta);\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function swap(\\n        PoolKey memory key,\\n        IPoolManager.SwapParams memory params,\\n        bytes calldata hookData\\n    ) external override returns (BalanceDelta delta) {\\n        if (key.hooks.shouldCallBeforeSwap()) {\\n            if (key.hooks.beforeSwap(msg.sender, key, params, hookData) != IHooks.beforeSwap.selector) {\\n                console.log('AHHHH');\\n                revert();\\n            }\\n        }\\n\\n        // Set the total swap fee, either through the hook or as the static fee set an initialization.\\n        uint24 totalSwapFee;\\n        if (key.fee.isDynamicFee()) {\\n            totalSwapFee = IDynamicFeeManager(address(key.hooks)).getFee(msg.sender, key, params, hookData);\\n            if (totalSwapFee >= 1000000) revert();\\n        } else {\\n            // clear the top 4 bits since they may be flagged for hook fees\\n            totalSwapFee = key.fee.getStaticFee();\\n        }\\n\\n        uint256 feeForProtocol;\\n        uint256 feeForHook;\\n        Pool.SwapState memory state;\\n        PoolId id = key.toId();\\n        (delta, feeForProtocol, feeForHook, state) = pools[id].swap(\\n            Pool.SwapParams({\\n                fee: totalSwapFee,\\n                tickSpacing: key.tickSpacing,\\n                zeroForOne: params.zeroForOne,\\n                amountSpecified: params.amountSpecified,\\n                sqrtPriceLimitX96: params.sqrtPriceLimitX96\\n            })\\n        );\\n\\n        _accountPoolBalanceDelta(key, delta);\\n        // the fee is on the input currency\\n\\n        unchecked {\\n            if (feeForProtocol > 0) {\\n                protocolFeesAccrued[params.zeroForOne ? key.currency0 : key.currency1] += feeForProtocol;\\n            }\\n            if (feeForHook > 0) {\\n                hookFeesAccrued[address(key.hooks)][params.zeroForOne ? key.currency0 : key.currency1] += feeForHook;\\n            }\\n        }\\n\\n        if (key.hooks.shouldCallAfterSwap()) {\\n            if (key.hooks.afterSwap(msg.sender, key, params, delta, hookData) != IHooks.afterSwap.selector) {\\n                revert();\\n            }\\n        }\\n\\n        // emit Swap(\\n        //     id,\\n        //     msg.sender,\\n        //     delta.amount0(),\\n        //     delta.amount1(),\\n        //     state.sqrtPriceX96,\\n        //     state.liquidity,\\n        //     state.tick,\\n        //     totalSwapFee\\n        // );\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function donate(\\n        PoolKey memory key,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata hookData\\n    ) external override returns (BalanceDelta delta) {\\n        if (key.hooks.shouldCallBeforeDonate()) {\\n            if (key.hooks.beforeDonate(msg.sender, key, amount0, amount1, hookData) != IHooks.beforeDonate.selector) {\\n                revert();\\n            }\\n        }\\n\\n        delta = _getPool(key).donate(amount0, amount1);\\n\\n        _accountPoolBalanceDelta(key, delta);\\n\\n        if (key.hooks.shouldCallAfterDonate()) {\\n            if (key.hooks.afterDonate(msg.sender, key, amount0, amount1, hookData) != IHooks.afterDonate.selector) {\\n                revert();\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function take(Currency currency, address to, uint256 amount) external override {\\n        _accountDelta(currency, amount.toInt128());\\n        reservesOf[currency] -= amount;\\n        currency.transfer(to, amount);\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function mint(Currency currency, address to, uint256 amount) external override {\\n        _accountDelta(currency, amount.toInt128());\\n        _mint(to, currency.toId(), amount, '');\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function settle(Currency currency) external payable override returns (uint256 paid) {\\n        uint256 reservesBefore = reservesOf[currency];\\n        reservesOf[currency] = currency.balanceOfSelf();\\n        paid = reservesOf[currency] - reservesBefore;\\n        // subtraction must be safe\\n        _accountDelta(currency, -(paid.toInt128()));\\n    }\\n\\n    function _burnAndAccount(Currency currency, uint256 amount) internal {\\n        _burn(address(this), currency.toId(), amount);\\n        _accountDelta(currency, -(amount.toInt128()));\\n    }\\n\\n    function onERC1155Received(address, address, uint256 id, uint256 value, bytes calldata) external returns (bytes4) {\\n        // if (msg.sender != address(this)) revert ();\\n        _burnAndAccount(CurrencyLibrary.fromId(id), value);\\n        return IERC1155Receiver.onERC1155Received.selector;\\n    }\\n\\n    // function onERC1155BatchReceived(\\n    //     address,\\n    //     address,\\n    //     uint256[] calldata ids,\\n    //     uint256[] calldata values,\\n    //     bytes calldata\\n    // ) external returns (bytes4) {\\n    //     if (msg.sender != address(this)) revert();\\n    //     // unchecked to save gas on incrementations of i\\n    //     unchecked {\\n    //         for (uint256 i; i < ids.length; i++) {\\n    //             _burnAndAccount(CurrencyLibrary.fromId(ids[i]), values[i]);\\n    //         }\\n    //     }\\n    //     return IERC1155Receiver.onERC1155BatchReceived.selector;\\n    // }\\n\\n    function setProtocolFees(PoolKey memory key) external {\\n        uint24 newProtocolFees = _fetchProtocolFees(key);\\n        PoolId id = key.toId();\\n        pools[id].setProtocolFees(newProtocolFees);\\n        //emit ProtocolFeeUpdated(id, newProtocolFees);\\n    }\\n\\n    function setHookFees(PoolKey memory key) external {\\n        uint24 newHookFees = _fetchHookFees(key);\\n        PoolId id = key.toId();\\n        pools[id].setHookFees(newHookFees);\\n        // emit HookFeeUpdated(id, newHookFees);\\n    }\\n\\n    function extsload(bytes32 slot) external view returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := sload(slot)\\n        }\\n    }\\n\\n    // function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes memory) {\\n    //     bytes memory value = new bytes(32 * nSlots);\\n\\n    //     /// @solidity memory-safe-assembly\\n    //     assembly {\\n    //         for {\\n    //             let i := 0\\n    //         } lt(i, nSlots) {\\n    //             i := add(i, 1)\\n    //         } {\\n    //             mstore(add(value, mul(add(i, 1), 32)), sload(add(startSlot, i)))\\n    //         }\\n    //     }\\n\\n    //     return value;\\n    // }\\n\\n    /// @notice receive native tokens for native pools\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0x27c62269c5f616dfc8fc144d28eef72f79d794c7170bfbb6da30abc805ced7b6\",\"license\":\"BUSL-1.1\"},\"@uniswap/v4-core/contracts/interfaces/IDynamicFeeManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {PoolKey} from \\\"../types/PoolKey.sol\\\";\\nimport {IPoolManager} from \\\"./IPoolManager.sol\\\";\\n\\n/// @notice The dynamic fee manager determines fees for pools\\n/// @dev note that this pool is only called if the PoolKey fee value is equal to the DYNAMIC_FEE magic value\\ninterface IDynamicFeeManager {\\n    function getFee(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata data)\\n        external\\n        returns (uint24);\\n}\\n\",\"keccak256\":\"0x025e7eb045536c46bb83e95cad52dea1c3ea9b9410c1f0588131b21e322b53d6\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/interfaces/IFees.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.19;\\n\\nimport {Currency} from '../types/Currency.sol';\\n\\ninterface IFees {\\n    /// @notice Thrown when the protocol fee denominator is less than 4. Also thrown when the static or dynamic fee on a pool is exceeds 100%.\\n    // error FeeTooLarge();\\n    // /// @notice Thrown when not enough gas is provided to look up the protocol fee\\n    // error ProtocolFeeCannotBeFetched();\\n\\n    // event ProtocolFeeControllerUpdated(address protocolFeeController);\\n\\n    /// @notice Returns the minimum denominator for the protocol fee, which restricts it to a maximum of 25%\\n    function MIN_PROTOCOL_FEE_DENOMINATOR() external view returns (uint8);\\n\\n    /// @notice Given a currency address, returns the protocol fees accrued in that currency\\n    function protocolFeesAccrued(Currency) external view returns (uint256);\\n\\n    /// @notice Given a hook and a currency address, returns the fees accrued\\n    function hookFeesAccrued(address, Currency) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xb60e72e2d34b9a3e3051c18d4a41bdae038c5365b26cb3cce95eac04ff1aa01c\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/interfaces/IHookFeeManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {PoolKey} from \\\"../types/PoolKey.sol\\\";\\n\\n/// @notice The interface for setting a fee on swap or fee on withdraw to the hook\\n/// @dev This callback is only made if the Fee.HOOK_SWAP_FEE_FLAG or Fee.HOOK_WITHDRAW_FEE_FLAG in set in the pool's key.fee.\\ninterface IHookFeeManager {\\n    /// @notice Gets the fee a hook can take at swap/withdraw. Upper bits used for swap and lower bits for withdraw.\\n    /// @param key The pool key\\n    /// @return The hook fees for swapping (upper bits set) and withdrawing (lower bits set).\\n    function getHookFees(PoolKey calldata key) external view returns (uint24);\\n}\\n\",\"keccak256\":\"0x0cbf84e24794abd7c1659f74f88fb41b78dc7483d082fc409c570197c850a97d\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/interfaces/IHooks.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {PoolKey} from \\\"../types/PoolKey.sol\\\";\\nimport {BalanceDelta} from \\\"../types/BalanceDelta.sol\\\";\\nimport {IPoolManager} from \\\"./IPoolManager.sol\\\";\\n\\n/// @notice The PoolManager contract decides whether to invoke specific hooks by inspecting the leading bits\\n/// of the hooks contract address. For example, a 1 bit in the first bit of the address will\\n/// cause the 'before swap' hook to be invoked. See the Hooks library for the full spec.\\n/// @dev Should only be callable by the v4 PoolManager.\\ninterface IHooks {\\n    /// @notice The hook called before the state of a pool is initialized\\n    /// @param sender The initial msg.sender for the initialize call\\n    /// @param key The key for the pool being initialized\\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\\n    /// @param hookData Arbitrary data handed into the PoolManager by the initializer to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, bytes calldata hookData)\\n        external\\n        returns (bytes4);\\n\\n    /// @notice The hook called after the state of a pool is initialized\\n    /// @param sender The initial msg.sender for the initialize call\\n    /// @param key The key for the pool being initialized\\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\\n    /// @param tick The current tick after the state of a pool is initialized\\n    /// @param hookData Arbitrary data handed into the PoolManager by the initializer to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function afterInitialize(\\n        address sender,\\n        PoolKey calldata key,\\n        uint160 sqrtPriceX96,\\n        int24 tick,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called before a position is modified\\n    /// @param sender The initial msg.sender for the modify position call\\n    /// @param key The key for the pool\\n    /// @param params The parameters for modifying the position\\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidty provider to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function beforeModifyPosition(\\n        address sender,\\n        PoolKey calldata key,\\n        IPoolManager.ModifyPositionParams calldata params,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called after a position is modified\\n    /// @param sender The initial msg.sender for the modify position call\\n    /// @param key The key for the pool\\n    /// @param params The parameters for modifying the position\\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidty provider to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function afterModifyPosition(\\n        address sender,\\n        PoolKey calldata key,\\n        IPoolManager.ModifyPositionParams calldata params,\\n        BalanceDelta delta,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called before a swap\\n    /// @param sender The initial msg.sender for the swap call\\n    /// @param key The key for the pool\\n    /// @param params The parameters for the swap\\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function beforeSwap(\\n        address sender,\\n        PoolKey calldata key,\\n        IPoolManager.SwapParams calldata params,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called after a swap\\n    /// @param sender The initial msg.sender for the swap call\\n    /// @param key The key for the pool\\n    /// @param params The parameters for the swap\\n    /// @param delta The amount owed to the locker (positive) or owed to the pool (negative)\\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function afterSwap(\\n        address sender,\\n        PoolKey calldata key,\\n        IPoolManager.SwapParams calldata params,\\n        BalanceDelta delta,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called before donate\\n    /// @param sender The initial msg.sender for the donate call\\n    /// @param key The key for the pool\\n    /// @param amount0 The amount of token0 being donated\\n    /// @param amount1 The amount of token1 being donated\\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function beforeDonate(\\n        address sender,\\n        PoolKey calldata key,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called after donate\\n    /// @param sender The initial msg.sender for the donate call\\n    /// @param key The key for the pool\\n    /// @param amount0 The amount of token0 being donated\\n    /// @param amount1 The amount of token1 being donated\\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function afterDonate(\\n        address sender,\\n        PoolKey calldata key,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x7263c9c8fef8b2346bebfd67956b287666a8c9e1f74131789650af4945ba4523\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/interfaces/IPoolManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Currency} from '../types/Currency.sol';\\nimport {PoolKey} from '../types/PoolKey.sol';\\nimport {Pool} from '../libraries/Pool.sol';\\nimport {IERC1155} from '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\\nimport {IHooks} from './IHooks.sol';\\nimport {IFees} from './IFees.sol';\\nimport {BalanceDelta} from '../types/BalanceDelta.sol';\\nimport {PoolId} from '../types/PoolId.sol';\\nimport {Position} from '../libraries/Position.sol';\\n\\ninterface IPoolManager is IFees, IERC1155 {\\n    /// @notice Thrown when currencies touched has exceeded max of 256\\n    // error MaxCurrenciesTouched();\\n\\n    // /// @notice Thrown when a currency is not netted out after a lock\\n    // error CurrencyNotSettled();\\n\\n    // /// @notice Thrown when a function is called by an address that is not the current locker\\n    // /// @param locker The current locker\\n    // error LockedBy(address locker);\\n\\n    // /// @notice The ERC1155 being deposited is not the Uniswap ERC1155\\n    // error NotPoolManagerToken();\\n\\n    // /// @notice Pools are limited to type(int16).max tickSpacing in #initialize, to prevent overflow\\n    // error TickSpacingTooLarge();\\n    // /// @notice Pools must have a positive non-zero tickSpacing passed to #initialize\\n    // error TickSpacingTooSmall();\\n\\n    // /// @notice PoolKey must have currencies where address(currency0) < address(currency1)\\n    // error CurrenciesInitializedOutOfOrder();\\n\\n    // /// @notice Emitted when a new pool is initialized\\n    // /// @param id The abi encoded hash of the pool key struct for the new pool\\n    // /// @param currency0 The first currency of the pool by address sort order\\n    // /// @param currency1 The second currency of the pool by address sort order\\n    // /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    // /// @param tickSpacing The minimum number of ticks between initialized ticks\\n    // /// @param hooks The hooks contract address for the pool, or address(0) if none\\n    // event Initialize(\\n    //     PoolId indexed id,\\n    //     Currency indexed currency0,\\n    //     Currency indexed currency1,\\n    //     uint24 fee,\\n    //     int24 tickSpacing,\\n    //     IHooks hooks\\n    // );\\n\\n    // /// @notice Emitted when a liquidity position is modified\\n    // /// @param id The abi encoded hash of the pool key struct for the pool that was modified\\n    // /// @param sender The address that modified the pool\\n    // /// @param tickLower The lower tick of the position\\n    // /// @param tickUpper The upper tick of the position\\n    // /// @param liquidityDelta The amount of liquidity that was added or removed\\n    // event ModifyPosition(\\n    //     PoolId indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta\\n    // );\\n\\n    // /// @notice Emitted for swaps between currency0 and currency1\\n    // /// @param id The abi encoded hash of the pool key struct for the pool that was modified\\n    // /// @param sender The address that initiated the swap call, and that received the callback\\n    // /// @param amount0 The delta of the currency0 balance of the pool\\n    // /// @param amount1 The delta of the currency1 balance of the pool\\n    // /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\\n    // /// @param liquidity The liquidity of the pool after the swap\\n    // /// @param tick The log base 1.0001 of the price of the pool after the swap\\n    // event Swap(\\n    //     PoolId indexed id,\\n    //     address indexed sender,\\n    //     int128 amount0,\\n    //     int128 amount1,\\n    //     uint160 sqrtPriceX96,\\n    //     uint128 liquidity,\\n    //     int24 tick,\\n    //     uint24 fee\\n    // );\\n\\n    // event ProtocolFeeUpdated(PoolId indexed id, uint24 protocolFees);\\n\\n    // event HookFeeUpdated(PoolId indexed id, uint24 hookFees);\\n\\n    /// @notice Returns the constant representing the maximum tickSpacing for an initialized pool key\\n    function MAX_TICK_SPACING() external view returns (int24);\\n\\n    /// @notice Returns the constant representing the minimum tickSpacing for an initialized pool key\\n    // function MIN_TICK_SPACING() external view returns (int24);\\n\\n    /// @notice Get the current value in slot0 of the given pool\\n    function getSlot0(\\n        PoolId id\\n    ) external view returns (uint160 sqrtPriceX96, int24 tick, uint24 protocolFees, uint24 hookFees);\\n\\n    /// @notice Get the current value of liquidity of the given pool\\n    function getLiquidity(PoolId id) external view returns (uint128 liquidity);\\n\\n    /// @notice Get the current value of liquidity for the specified pool and position\\n    function getLiquidity(\\n        PoolId id,\\n        address owner,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) external view returns (uint128 liquidity);\\n\\n    /// @notice Get the position struct for a specified pool and position\\n    function getPosition(\\n        PoolId id,\\n        address owner,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) external view returns (Position.Info memory position);\\n\\n    /// @notice Returns the reserves for a given ERC20 currency\\n    function reservesOf(Currency currency) external view returns (uint256);\\n\\n    /// @notice Contains data about pool lockers.\\n    struct LockData {\\n        /// @notice The current number of active lockers\\n        uint128 length;\\n        /// @notice The total number of nonzero deltas over all active + completed lockers\\n        uint128 nonzeroDeltaCount;\\n    }\\n\\n    /// @notice Returns the locker in the ith position of the locker queue.\\n    function getLock(uint256 i) external view returns (address locker);\\n\\n    /// @notice Returns lock data\\n    function lockData() external view returns (uint128 length, uint128 nonzeroDeltaCount);\\n\\n    /// @notice Initialize the state for a given pool ID\\n    function initialize(\\n        PoolKey memory key,\\n        uint160 sqrtPriceX96,\\n        bytes calldata hookData\\n    ) external returns (int24 tick);\\n\\n    /// @notice Get the current delta for a locker in the given currency\\n    /// @param locker The address of the locker\\n    /// @param currency The currency for which to lookup the delta\\n    function currencyDelta(address locker, Currency currency) external view returns (int256);\\n\\n    /// @notice All operations go through this function\\n    /// @param data Any data to pass to the callback, via `ILockCallback(msg.sender).lockCallback(data)`\\n    /// @return The data returned by the call to `ILockCallback(msg.sender).lockCallback(data)`\\n    function lock(bytes calldata data) external returns (bytes memory);\\n\\n    struct ModifyPositionParams {\\n        // the lower and upper tick of the position\\n        int24 tickLower;\\n        int24 tickUpper;\\n        // how to modify the liquidity\\n        int256 liquidityDelta;\\n    }\\n\\n    /// @notice Modify the position for the given pool\\n    function modifyPosition(\\n        PoolKey memory key,\\n        ModifyPositionParams memory params,\\n        bytes calldata hookData\\n    ) external returns (BalanceDelta);\\n\\n    struct SwapParams {\\n        bool zeroForOne;\\n        int256 amountSpecified;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swap against the given pool\\n    function swap(\\n        PoolKey memory key,\\n        SwapParams memory params,\\n        bytes calldata hookData\\n    ) external returns (BalanceDelta);\\n\\n    /// @notice Donate the given currency amounts to the pool with the given pool key\\n    function donate(\\n        PoolKey memory key,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata hookData\\n    ) external returns (BalanceDelta);\\n\\n    /// @notice Called by the user to net out some value owed to the user\\n    /// @dev Can also be used as a mechanism for _free_ flash loans\\n    function take(Currency currency, address to, uint256 amount) external;\\n\\n    /// @notice Called by the user to move value into ERC1155 balance\\n    function mint(Currency token, address to, uint256 amount) external;\\n\\n    /// @notice Called by the user to pay what is owed\\n    function settle(Currency token) external payable returns (uint256 paid);\\n\\n    /// @notice Sets the protocol's swap and withdrawal fees for the given pool\\n    /// Protocol fees are always a portion of a fee that is owed. If that underlying fee is 0, no protocol fees will accrue even if it is set to > 0.\\n    function setProtocolFees(PoolKey memory key) external;\\n\\n    /// @notice Sets the hook's swap and withdrawal fees for the given pool\\n    function setHookFees(PoolKey memory key) external;\\n\\n    /// @notice Called by external contracts to access granular pool state\\n    /// @param slot Key of slot to sload\\n    /// @return value The value of the slot as bytes32\\n    function extsload(bytes32 slot) external view returns (bytes32 value);\\n\\n    /// @notice Called by external contracts to access granular pool state\\n    /// @param slot Key of slot to start sloading from\\n    /// @param nSlots Number of slots to load into return value\\n    /// @return value The value of the sload-ed slots concatenated as dynamic bytes\\n    //function extsload(bytes32 slot, uint256 nSlots) external view returns (bytes memory value);\\n}\\n\",\"keccak256\":\"0xc4dd5ef5a28c912508c4c54d83db5cacde59b56d80c80d27e5eac9bec6bd5da4\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/interfaces/IProtocolFeeController.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {PoolKey} from \\\"../types/PoolKey.sol\\\";\\n\\ninterface IProtocolFeeController {\\n    /// @notice Returns the protocol fees for a pool given the conditions of this contract\\n    /// @param poolKey The pool key to identify the pool. The controller may want to use attributes on the pool\\n    ///   to determine the protocol fee, hence the entire key is needed.\\n    function protocolFeesForPool(PoolKey memory poolKey) external view returns (uint24);\\n}\\n\",\"keccak256\":\"0x8cfe1e67530ab254d9f0333d391d5f80719921902e5a1f1d6d1f93eb76642953\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/interfaces/callback/ILockCallback.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\ninterface ILockCallback {\\n    /// @notice Called by the pool manager on `msg.sender` when a lock is acquired\\n    /// @param data The data that was passed to the call to lock\\n    /// @return Any data that you want to be returned from the lock call\\n    function lockAcquired(bytes calldata data) external returns (bytes memory);\\n}\\n\",\"keccak256\":\"0xbbe48da53b400e2ebe65e8b2d7fff212f4da3657bafec984c9144387c98f1816\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/interfaces/external/IERC20Minimal.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title Minimal ERC20 interface for Uniswap\\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\\ninterface IERC20Minimal {\\n    /// @notice Returns the balance of a token\\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\\n    /// @return The number of tokens held by the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\\n    /// @param recipient The account that will receive the amount transferred\\n    /// @param amount The number of tokens to send from the sender to the recipient\\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the current allowance given to a spender by an owner\\n    /// @param owner The account of the token owner\\n    /// @param spender The account of the token spender\\n    /// @return The current allowance granted by `owner` to `spender`\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\\n    /// @param amount The amount of tokens allowed to be used by `spender`\\n    /// @return Returns true for a successful approval, false for unsuccessful\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\\n    /// @param sender The account from which the transfer will be initiated\\n    /// @param recipient The recipient of the transfer\\n    /// @param amount The amount of the transfer\\n    /// @return Returns true for a successful transfer, false for unsuccessful\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\\n    /// @param value The amount of tokens that were transferred\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\\n    /// @param owner The account that approved spending of its tokens\\n    /// @param spender The account for which the spending allowance was modified\\n    /// @param value The new allowance from the owner to the spender\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x8dc5ee72426906aeb12f4ae6a2426df059491739bd5cbdb8ea4a3e26970436c6\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/BitMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title BitMath\\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\\nlibrary BitMath {\\n    /// @notice Returns the index of the most significant bit of the number,\\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\\n    /// @dev The function satisfies the property:\\n    ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\\n    /// @return r the index of the most significant bit\\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\\n        require(x > 0);\\n\\n        unchecked {\\n            if (x >= 0x100000000000000000000000000000000) {\\n                x >>= 128;\\n                r += 128;\\n            }\\n            if (x >= 0x10000000000000000) {\\n                x >>= 64;\\n                r += 64;\\n            }\\n            if (x >= 0x100000000) {\\n                x >>= 32;\\n                r += 32;\\n            }\\n            if (x >= 0x10000) {\\n                x >>= 16;\\n                r += 16;\\n            }\\n            if (x >= 0x100) {\\n                x >>= 8;\\n                r += 8;\\n            }\\n            if (x >= 0x10) {\\n                x >>= 4;\\n                r += 4;\\n            }\\n            if (x >= 0x4) {\\n                x >>= 2;\\n                r += 2;\\n            }\\n            if (x >= 0x2) r += 1;\\n        }\\n    }\\n\\n    /// @notice Returns the index of the least significant bit of the number,\\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\\n    /// @dev The function satisfies the property:\\n    ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\\n    /// @return r the index of the least significant bit\\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\\n        require(x > 0);\\n\\n        unchecked {\\n            r = 255;\\n            if (x & type(uint128).max > 0) {\\n                r -= 128;\\n            } else {\\n                x >>= 128;\\n            }\\n            if (x & type(uint64).max > 0) {\\n                r -= 64;\\n            } else {\\n                x >>= 64;\\n            }\\n            if (x & type(uint32).max > 0) {\\n                r -= 32;\\n            } else {\\n                x >>= 32;\\n            }\\n            if (x & type(uint16).max > 0) {\\n                r -= 16;\\n            } else {\\n                x >>= 16;\\n            }\\n            if (x & type(uint8).max > 0) {\\n                r -= 8;\\n            } else {\\n                x >>= 8;\\n            }\\n            if (x & 0xf > 0) {\\n                r -= 4;\\n            } else {\\n                x >>= 4;\\n            }\\n            if (x & 0x3 > 0) {\\n                r -= 2;\\n            } else {\\n                x >>= 2;\\n            }\\n            if (x & 0x1 > 0) r -= 1;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x652cd36970d953b3067c766b3b0c0063d4c403eba7352df09ec10dcc868910d9\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/FeeLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nlibrary FeeLibrary {\\n    uint24 public constant STATIC_FEE_MASK = 0x0FFFFF;\\n    uint24 public constant DYNAMIC_FEE_FLAG = 0x800000; // 1000\\n    uint24 public constant HOOK_SWAP_FEE_FLAG = 0x400000; // 0100\\n    uint24 public constant HOOK_WITHDRAW_FEE_FLAG = 0x200000; // 0010\\n\\n    function isDynamicFee(uint24 self) internal pure returns (bool) {\\n        return self & DYNAMIC_FEE_FLAG != 0;\\n    }\\n\\n    function hasHookSwapFee(uint24 self) internal pure returns (bool) {\\n        return self & HOOK_SWAP_FEE_FLAG != 0;\\n    }\\n\\n    function hasHookWithdrawFee(uint24 self) internal pure returns (bool) {\\n        return self & HOOK_WITHDRAW_FEE_FLAG != 0;\\n    }\\n\\n    function isStaticFeeTooLarge(uint24 self) internal pure returns (bool) {\\n        return self & STATIC_FEE_MASK >= 1000000;\\n    }\\n\\n    function getStaticFee(uint24 self) internal pure returns (uint24) {\\n        return self & STATIC_FEE_MASK;\\n    }\\n}\\n\",\"keccak256\":\"0x9fc00b77978b617d1a9b5c9d024210b43ee5455682982703d3009bfafc1c12b4\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/FixedPoint128.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title FixedPoint128\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\nlibrary FixedPoint128 {\\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\\n}\\n\",\"keccak256\":\"0x1f015a7a107f4c471985a958f1bfbc1710948f9bcd3786a02310bc0ad5080c69\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/FixedPoint96.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title FixedPoint96\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\n/// @dev Used in SqrtPriceMath.sol\\nlibrary FixedPoint96 {\\n    uint8 internal constant RESOLUTION = 96;\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n}\\n\",\"keccak256\":\"0x7731aeeba692b0ca5dac8f27803ec9e5ce98795a554c09ae05c220861bd0314e\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0 = a * b; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (0 - denominator) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the preconditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = mulDiv(a, b, denominator);\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6d8760794ed38264579c5da7b2afe8ff5543de999180850bc08687b77dce36ea\",\"license\":\"MIT\"},\"@uniswap/v4-core/contracts/libraries/Hooks.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.20;\\n\\nimport {IHooks} from '../interfaces/IHooks.sol';\\nimport {FeeLibrary} from '../libraries/FeeLibrary.sol';\\nimport 'hardhat/console.sol';\\n\\n/// @notice V4 decides whether to invoke specific hooks by inspecting the leading bits of the address that\\n/// the hooks contract is deployed to.\\n/// For example, a hooks contract deployed to address: 0x9000000000000000000000000000000000000000\\n/// has leading bits '1001' which would cause the 'before initialize' and 'after modify position' hooks to be used.\\nlibrary Hooks {\\n    using FeeLibrary for uint24;\\n\\n    uint256 internal constant BEFORE_INITIALIZE_FLAG = 1 << 159;\\n    uint256 internal constant AFTER_INITIALIZE_FLAG = 1 << 158;\\n    uint256 internal constant BEFORE_MODIFY_POSITION_FLAG = 1 << 157;\\n    uint256 internal constant AFTER_MODIFY_POSITION_FLAG = 1 << 156;\\n    uint256 internal constant BEFORE_SWAP_FLAG = 1 << 155;\\n    uint256 internal constant AFTER_SWAP_FLAG = 1 << 154;\\n    uint256 internal constant BEFORE_DONATE_FLAG = 1 << 153;\\n    uint256 internal constant AFTER_DONATE_FLAG = 1 << 152;\\n\\n    struct Calls {\\n        bool beforeInitialize;\\n        bool afterInitialize;\\n        bool beforeModifyPosition;\\n        bool afterModifyPosition;\\n        bool beforeSwap;\\n        bool afterSwap;\\n        bool beforeDonate;\\n        bool afterDonate;\\n    }\\n\\n    /// @notice Thrown if the address will not lead to the specified hook calls being called\\n    /// @param hooks The address of the hooks contract\\n    error HookAddressNotValid(address hooks);\\n\\n    /// @notice Hook did not return its selector\\n    error InvalidHookResponse();\\n\\n    /// @notice Utility function intended to be used in hook constructors to ensure\\n    /// the deployed hooks address causes the intended hooks to be called\\n    /// @param calls The hooks that are intended to be called\\n    /// @dev calls param is memory as the function will be called from constructors\\n    function validateHookAddress(IHooks self, Calls memory calls) internal pure {\\n        console.log(address(self));\\n        console.log(calls.beforeInitialize != shouldCallBeforeInitialize(self));\\n        console.log(calls.afterInitialize != shouldCallAfterInitialize(self));\\n        console.log(calls.beforeModifyPosition != shouldCallBeforeModifyPosition(self));\\n        console.log(calls.afterModifyPosition != shouldCallAfterModifyPosition(self));\\n        console.log(calls.beforeSwap != shouldCallBeforeSwap(self));\\n        console.log(calls.afterSwap != shouldCallAfterSwap(self));\\n        console.log(calls.beforeDonate != shouldCallBeforeDonate(self));\\n        console.log(calls.afterDonate != shouldCallAfterDonate(self));\\n\\n        if (\\n            calls.beforeInitialize != shouldCallBeforeInitialize(self) ||\\n            calls.afterInitialize != shouldCallAfterInitialize(self) ||\\n            calls.beforeModifyPosition != shouldCallBeforeModifyPosition(self) ||\\n            calls.afterModifyPosition != shouldCallAfterModifyPosition(self) ||\\n            calls.beforeSwap != shouldCallBeforeSwap(self) ||\\n            calls.afterSwap != shouldCallAfterSwap(self) ||\\n            calls.beforeDonate != shouldCallBeforeDonate(self) ||\\n            calls.afterDonate != shouldCallAfterDonate(self)\\n        ) {\\n            revert HookAddressNotValid(address(self));\\n        }\\n    }\\n\\n    /// @notice Ensures that the hook address includes at least one hook flag or dynamic fees, or is the 0 address\\n    /// @param hook The hook to verify\\n    function isValidHookAddress(IHooks hook, uint24 fee) internal pure returns (bool) {\\n        // If there is no hook contract set, then fee cannot be dynamic and there cannot be a hook fee on swap or withdrawal.\\n        return\\n            address(hook) == address(0)\\n                ? !fee.isDynamicFee() && !fee.hasHookSwapFee() && !fee.hasHookWithdrawFee()\\n                : (uint160(address(hook)) >= AFTER_DONATE_FLAG ||\\n                    fee.isDynamicFee() ||\\n                    fee.hasHookSwapFee() ||\\n                    fee.hasHookWithdrawFee());\\n    }\\n\\n    function shouldCallBeforeInitialize(IHooks self) internal pure returns (bool) {\\n        return uint256(uint160(address(self))) & BEFORE_INITIALIZE_FLAG != 0;\\n    }\\n\\n    function shouldCallAfterInitialize(IHooks self) internal pure returns (bool) {\\n        return uint256(uint160(address(self))) & AFTER_INITIALIZE_FLAG != 0;\\n    }\\n\\n    function shouldCallBeforeModifyPosition(IHooks self) internal pure returns (bool) {\\n        return uint256(uint160(address(self))) & BEFORE_MODIFY_POSITION_FLAG != 0;\\n    }\\n\\n    function shouldCallAfterModifyPosition(IHooks self) internal pure returns (bool) {\\n        return uint256(uint160(address(self))) & AFTER_MODIFY_POSITION_FLAG != 0;\\n    }\\n\\n    function shouldCallBeforeSwap(IHooks self) internal pure returns (bool) {\\n        return uint256(uint160(address(self))) & BEFORE_SWAP_FLAG != 0;\\n    }\\n\\n    function shouldCallAfterSwap(IHooks self) internal pure returns (bool) {\\n        return uint256(uint160(address(self))) & AFTER_SWAP_FLAG != 0;\\n    }\\n\\n    function shouldCallBeforeDonate(IHooks self) internal pure returns (bool) {\\n        return uint256(uint160(address(self))) & BEFORE_DONATE_FLAG != 0;\\n    }\\n\\n    function shouldCallAfterDonate(IHooks self) internal pure returns (bool) {\\n        return uint256(uint160(address(self))) & AFTER_DONATE_FLAG != 0;\\n    }\\n}\\n\",\"keccak256\":\"0x7b49e4b200269e0dae9db3b81dd9ef0888f216bba5d2a2c552f1c8094b1cf511\",\"license\":\"BUSL-1.1\"},\"@uniswap/v4-core/contracts/libraries/LockDataLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.20;\\n\\nimport {IPoolManager} from \\\"../interfaces/IPoolManager.sol\\\";\\n\\n/// @dev This library manages a custom storage implementation for a queue\\n///      that tracks current lockers. The \\\"sentinel\\\" storage slot for this data structure,\\n///      always passed in as IPoolManager.LockData storage self, stores not just the current\\n///      length of the queue but also the global count of non-zero deltas across all lockers.\\n///      The values of the data structure start at OFFSET, and each value is a locker address.\\nlibrary LockDataLibrary {\\n    uint256 private constant OFFSET = uint256(keccak256(\\\"LockData\\\"));\\n\\n    /// @dev Pushes a locker onto the end of the queue, and updates the sentinel storage slot.\\n    function push(IPoolManager.LockData storage self, address locker) internal {\\n        // read current value from the sentinel storage slot\\n        uint128 length = self.length;\\n        unchecked {\\n            uint256 indexToWrite = OFFSET + length; // not in assembly because OFFSET is in the library scope\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // in the next storage slot, write the locker\\n                sstore(indexToWrite, locker)\\n            }\\n            // update the sentinel storage slot\\n            self.length = length + 1;\\n        }\\n    }\\n\\n    /// @dev Pops a locker off the end of the queue. Note that no storage gets cleared.\\n    function pop(IPoolManager.LockData storage self) internal {\\n        unchecked {\\n            self.length--;\\n        }\\n    }\\n\\n    function getLock(uint256 i) internal view returns (address locker) {\\n        unchecked {\\n            uint256 position = OFFSET + i; // not in assembly because OFFSET is in the library scope\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                locker := sload(position)\\n            }\\n        }\\n    }\\n\\n    function getActiveLock(IPoolManager.LockData storage self) internal view returns (address locker) {\\n        return getLock(self.length - 1);\\n    }\\n}\\n\",\"keccak256\":\"0xf4be97b50bca4e569e0e2c8555b11e7397bf79c04fc0322c9d74a9a87fa31674\",\"license\":\"BUSL-1.1\"},\"@uniswap/v4-core/contracts/libraries/Pool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.20;\\n\\nimport {SafeCast} from './SafeCast.sol';\\nimport {TickBitmap} from './TickBitmap.sol';\\nimport {Position} from './Position.sol';\\nimport {FullMath} from './FullMath.sol';\\nimport {FixedPoint128} from './FixedPoint128.sol';\\nimport {TickMath} from './TickMath.sol';\\nimport {SqrtPriceMath} from './SqrtPriceMath.sol';\\nimport {SwapMath} from './SwapMath.sol';\\nimport {BalanceDelta, toBalanceDelta} from '../types/BalanceDelta.sol';\\nimport 'hardhat/console.sol';\\n\\nlibrary Pool {\\n    using SafeCast for *;\\n    using TickBitmap for mapping(int16 => uint256);\\n    using Position for mapping(bytes32 => Position.Info);\\n    using Position for Position.Info;\\n\\n    /// @notice Thrown when tickLower is not below tickUpper\\n    /// @param tickLower The invalid tickLower\\n    /// @param tickUpper The invalid tickUpper\\n    error TicksMisordered(int24 tickLower, int24 tickUpper);\\n\\n    /// @notice Thrown when tickLower is less than min tick\\n    /// @param tickLower The invalid tickLower\\n    error TickLowerOutOfBounds(int24 tickLower);\\n\\n    /// @notice Thrown when tickUpper exceeds max tick\\n    /// @param tickUpper The invalid tickUpper\\n    error TickUpperOutOfBounds(int24 tickUpper);\\n\\n    /// @notice For the tick spacing, the tick has too much liquidity\\n    error TickLiquidityOverflow(int24 tick);\\n\\n    /// @notice Thrown when interacting with an uninitialized tick that must be initialized\\n    /// @param tick The uninitialized tick\\n    error TickNotInitialized(int24 tick);\\n\\n    /// @notice Thrown when trying to initalize an already initialized pool\\n    error PoolAlreadyInitialized();\\n\\n    /// @notice Thrown when trying to interact with a non-initialized pool\\n    error PoolNotInitialized();\\n\\n    /// @notice Thrown when trying to swap amount of 0\\n    error SwapAmountCannotBeZero();\\n\\n    /// @notice Thrown when sqrtPriceLimitX96 on a swap has already exceeded its limit\\n    /// @param sqrtPriceCurrentX96 The invalid, already surpassed sqrtPriceLimitX96\\n    /// @param sqrtPriceLimitX96 The surpassed price limit\\n    error PriceLimitAlreadyExceeded(uint160 sqrtPriceCurrentX96, uint160 sqrtPriceLimitX96);\\n\\n    /// @notice Thrown when sqrtPriceLimitX96 lies outside of valid tick/price range\\n    /// @param sqrtPriceLimitX96 The invalid, out-of-bounds sqrtPriceLimitX96\\n    error PriceLimitOutOfBounds(uint160 sqrtPriceLimitX96);\\n\\n    /// @notice Thrown by donate if there is currently 0 liquidity, since the fees will not go to any liquidity providers\\n    error NoLiquidityToReceiveFees();\\n\\n    /// Each uint24 variable packs both the swap fees and the withdraw fees represented as integer denominators (1/x). The upper 12 bits are the swap fees, and the lower 12 bits\\n    /// are the withdraw fees. For swap fees, the upper 6 bits are the fee for trading 1 for 0, and the lower 6 are for 0 for 1 and are taken as a percentage of the lp swap fee.\\n    /// For withdraw fees the upper 6 bits are the fee on amount1, and the lower 6 are for amount0 and are taken as a percentage of the principle amount of the underlying position.\\n    /// bits          24 22 20 18 16 14 12 10 8  6  4  2  0\\n    ///               |    swapFees     |   withdrawFees  |\\n    ///               \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\n    /// protocolFees: | 1->0   |  0->1  |  fee1  |  fee0  |\\n    /// hookFees:     | 1->0   |  0->1  |  fee1  |  fee0  |\\n    ///               \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n    struct Slot0 {\\n        // the current price\\n        uint160 sqrtPriceX96;\\n        // the current tick\\n        int24 tick;\\n        uint24 protocolFees;\\n        uint24 hookFees;\\n    }\\n    // 24 bits left!\\n\\n    // info stored for each initialized individual tick\\n    struct TickInfo {\\n        // the total position liquidity that references this tick\\n        uint128 liquidityGross;\\n        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\\n        int128 liquidityNet;\\n        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        uint256 feeGrowthOutside0X128;\\n        uint256 feeGrowthOutside1X128;\\n    }\\n\\n    /// @dev The state of a pool\\n    struct State {\\n        Slot0 slot0;\\n        uint256 feeGrowthGlobal0X128;\\n        uint256 feeGrowthGlobal1X128;\\n        uint128 liquidity;\\n        mapping(int24 => TickInfo) ticks;\\n        mapping(int16 => uint256) tickBitmap;\\n        mapping(bytes32 => Position.Info) positions;\\n    }\\n\\n    /// @dev Common checks for valid tick inputs.\\n    function checkTicks(int24 tickLower, int24 tickUpper) private pure {\\n        if (tickLower >= tickUpper) revert TicksMisordered(tickLower, tickUpper);\\n        if (tickLower < TickMath.MIN_TICK) revert TickLowerOutOfBounds(tickLower);\\n        if (tickUpper > TickMath.MAX_TICK) revert TickUpperOutOfBounds(tickUpper);\\n    }\\n\\n    function initialize(\\n        State storage self,\\n        uint160 sqrtPriceX96,\\n        uint24 protocolFees,\\n        uint24 hookFees\\n    ) internal returns (int24 tick) {\\n        if (self.slot0.sqrtPriceX96 != 0) revert PoolAlreadyInitialized();\\n\\n        tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);\\n\\n        self.slot0 = Slot0({sqrtPriceX96: sqrtPriceX96, tick: tick, protocolFees: protocolFees, hookFees: hookFees});\\n    }\\n\\n    function getSwapFee(uint24 feesStorage) internal pure returns (uint16) {\\n        return uint16(feesStorage >> 12);\\n    }\\n\\n    function getWithdrawFee(uint24 feesStorage) internal pure returns (uint16) {\\n        return uint16(feesStorage & 0xFFF);\\n    }\\n\\n    function setProtocolFees(State storage self, uint24 protocolFees) internal {\\n        if (self.slot0.sqrtPriceX96 == 0) revert PoolNotInitialized();\\n\\n        self.slot0.protocolFees = protocolFees;\\n    }\\n\\n    function setHookFees(State storage self, uint24 hookFees) internal {\\n        if (self.slot0.sqrtPriceX96 == 0) revert PoolNotInitialized();\\n\\n        self.slot0.hookFees = hookFees;\\n    }\\n\\n    struct ModifyPositionParams {\\n        // the address that owns the position\\n        address owner;\\n        // the lower and upper tick of the position\\n        int24 tickLower;\\n        int24 tickUpper;\\n        // any change in liquidity\\n        int128 liquidityDelta;\\n        // the spacing between ticks\\n        int24 tickSpacing;\\n    }\\n\\n    struct ModifyPositionState {\\n        bool flippedLower;\\n        uint128 liquidityGrossAfterLower;\\n        bool flippedUpper;\\n        uint128 liquidityGrossAfterUpper;\\n        uint256 feeGrowthInside0X128;\\n        uint256 feeGrowthInside1X128;\\n    }\\n\\n    struct FeeAmounts {\\n        uint256 feeForProtocol0;\\n        uint256 feeForProtocol1;\\n        uint256 feeForHook0;\\n        uint256 feeForHook1;\\n    }\\n\\n    /// @dev Effect changes to a position in a pool\\n    /// @param params the position details and the change to the position's liquidity to effect\\n    /// @return result the deltas of the token balances of the pool\\n    function modifyPosition(\\n        State storage self,\\n        ModifyPositionParams memory params\\n    ) internal returns (BalanceDelta result, FeeAmounts memory fees) {\\n        if (self.slot0.sqrtPriceX96 == 0) revert PoolNotInitialized();\\n\\n        checkTicks(params.tickLower, params.tickUpper);\\n\\n        uint256 feesOwed0;\\n        uint256 feesOwed1;\\n        {\\n            ModifyPositionState memory state;\\n            // if we need to update the ticks, do it\\n\\n            if (params.liquidityDelta != 0) {\\n                (state.flippedLower, state.liquidityGrossAfterLower) = updateTick(\\n                    self,\\n                    params.tickLower,\\n                    params.liquidityDelta,\\n                    false\\n                );\\n                (state.flippedUpper, state.liquidityGrossAfterUpper) = updateTick(\\n                    self,\\n                    params.tickUpper,\\n                    params.liquidityDelta,\\n                    true\\n                );\\n\\n                if (params.liquidityDelta > 0) {\\n                    uint128 maxLiquidityPerTick = tickSpacingToMaxLiquidityPerTick(params.tickSpacing);\\n                    if (state.liquidityGrossAfterLower > maxLiquidityPerTick) {\\n                        revert TickLiquidityOverflow(params.tickLower);\\n                    }\\n                    if (state.liquidityGrossAfterUpper > maxLiquidityPerTick) {\\n                        revert TickLiquidityOverflow(params.tickUpper);\\n                    }\\n                }\\n\\n                if (state.flippedLower) {\\n                    self.tickBitmap.flipTick(params.tickLower, params.tickSpacing);\\n                }\\n                if (state.flippedUpper) {\\n                    self.tickBitmap.flipTick(params.tickUpper, params.tickSpacing);\\n                }\\n            }\\n\\n            (state.feeGrowthInside0X128, state.feeGrowthInside1X128) = getFeeGrowthInside(\\n                self,\\n                params.tickLower,\\n                params.tickUpper\\n            );\\n            console.log('AL', params.owner, uint24(-params.tickLower), uint24(params.tickUpper));\\n            console.log(state.feeGrowthInside0X128, state.feeGrowthInside1X128);\\n            (feesOwed0, feesOwed1) = self.positions.get(params.owner, params.tickLower, params.tickUpper).update(\\n                params.liquidityDelta,\\n                state.feeGrowthInside0X128,\\n                state.feeGrowthInside1X128\\n            );\\n\\n            // clear any tick data that is no longer needed\\n            if (params.liquidityDelta < 0) {\\n                if (state.flippedLower) {\\n                    clearTick(self, params.tickLower);\\n                }\\n                if (state.flippedUpper) {\\n                    clearTick(self, params.tickUpper);\\n                }\\n            }\\n        }\\n\\n        if (params.liquidityDelta != 0) {\\n            if (self.slot0.tick < params.tickLower) {\\n                // current tick is below the passed range; liquidity can only become in range by crossing from left to\\n                // right, when we'll need _more_ currency0 (it's becoming more valuable) so user must provide it\\n                result =\\n                    result +\\n                    toBalanceDelta(\\n                        SqrtPriceMath\\n                            .getAmount0Delta(\\n                                TickMath.getSqrtRatioAtTick(params.tickLower),\\n                                TickMath.getSqrtRatioAtTick(params.tickUpper),\\n                                params.liquidityDelta\\n                            )\\n                            .toInt128(),\\n                        0\\n                    );\\n            } else if (self.slot0.tick < params.tickUpper) {\\n                result =\\n                    result +\\n                    toBalanceDelta(\\n                        SqrtPriceMath\\n                            .getAmount0Delta(\\n                                self.slot0.sqrtPriceX96,\\n                                TickMath.getSqrtRatioAtTick(params.tickUpper),\\n                                params.liquidityDelta\\n                            )\\n                            .toInt128(),\\n                        SqrtPriceMath\\n                            .getAmount1Delta(\\n                                TickMath.getSqrtRatioAtTick(params.tickLower),\\n                                self.slot0.sqrtPriceX96,\\n                                params.liquidityDelta\\n                            )\\n                            .toInt128()\\n                    );\\n\\n                self.liquidity = params.liquidityDelta < 0\\n                    ? self.liquidity - uint128(-params.liquidityDelta)\\n                    : self.liquidity + uint128(params.liquidityDelta);\\n            } else {\\n                // current tick is above the passed range; liquidity can only become in range by crossing from right to\\n                // left, when we'll need _more_ currency1 (it's becoming more valuable) so user must provide it\\n                result =\\n                    result +\\n                    toBalanceDelta(\\n                        0,\\n                        SqrtPriceMath\\n                            .getAmount1Delta(\\n                                TickMath.getSqrtRatioAtTick(params.tickLower),\\n                                TickMath.getSqrtRatioAtTick(params.tickUpper),\\n                                params.liquidityDelta\\n                            )\\n                            .toInt128()\\n                    );\\n            }\\n        }\\n\\n        if (params.liquidityDelta < 0 && getWithdrawFee(self.slot0.hookFees) > 0) {\\n            // Only take fees if the hook withdraw fee is set and the liquidity is being removed.\\n            fees = _calculateExternalFees(self, result);\\n\\n            // Amounts are balances owed to the pool. When negative, they represent the balance a user can take.\\n            // Since protocol and hook fees are extracted on the balance a user can take\\n            // they are owed (added) back to the pool where they are kept to be collected by the fee recipients.\\n            result =\\n                result +\\n                toBalanceDelta(\\n                    fees.feeForHook0.toInt128() + fees.feeForProtocol0.toInt128(),\\n                    fees.feeForHook1.toInt128() + fees.feeForProtocol1.toInt128()\\n                );\\n        }\\n\\n        // Fees earned from LPing are removed from the pool balance.\\n        result = result - toBalanceDelta(feesOwed0.toInt128(), feesOwed1.toInt128());\\n    }\\n\\n    function _calculateExternalFees(\\n        State storage self,\\n        BalanceDelta result\\n    ) internal view returns (FeeAmounts memory fees) {\\n        int128 amount0 = result.amount0();\\n        int128 amount1 = result.amount1();\\n\\n        Slot0 memory slot0Cache = self.slot0;\\n        uint24 hookFees = slot0Cache.hookFees;\\n        uint24 protocolFees = slot0Cache.protocolFees;\\n\\n        uint16 hookFee0 = getWithdrawFee(hookFees) % 64;\\n        uint16 hookFee1 = getWithdrawFee(hookFees) >> 6;\\n\\n        uint16 protocolFee0 = getWithdrawFee(protocolFees) % 64;\\n        uint16 protocolFee1 = getWithdrawFee(protocolFees) >> 6;\\n\\n        if (amount0 < 0 && hookFee0 > 0) {\\n            fees.feeForHook0 = uint128(-amount0) / hookFee0;\\n        }\\n        if (amount1 < 0 && hookFee1 > 0) {\\n            fees.feeForHook1 = uint128(-amount1) / hookFee1;\\n        }\\n\\n        // A protocol fee is only applied if the hook fee is applied.\\n        if (protocolFee0 > 0 && fees.feeForHook0 > 0) {\\n            fees.feeForProtocol0 = fees.feeForHook0 / protocolFee0;\\n            fees.feeForHook0 -= fees.feeForProtocol0;\\n        }\\n\\n        if (protocolFee1 > 0 && fees.feeForHook1 > 0) {\\n            fees.feeForProtocol1 = fees.feeForHook1 / protocolFee1;\\n            fees.feeForHook1 -= fees.feeForProtocol1;\\n        }\\n\\n        return fees;\\n    }\\n\\n    struct SwapCache {\\n        // liquidity at the beginning of the swap\\n        uint128 liquidityStart;\\n        // the protocol fee for the input token\\n        uint16 protocolFee;\\n        // the hook fee for the input token\\n        uint16 hookFee;\\n    }\\n\\n    // the top level state of the swap, the results of which are recorded in storage at the end\\n    struct SwapState {\\n        // the amount remaining to be swapped in/out of the input/output asset\\n        int256 amountSpecifiedRemaining;\\n        // the amount already swapped out/in of the output/input asset\\n        int256 amountCalculated;\\n        // current sqrt(price)\\n        uint160 sqrtPriceX96;\\n        // the tick associated with the current price\\n        int24 tick;\\n        // the global fee growth of the input token\\n        uint256 feeGrowthGlobalX128;\\n        // the current liquidity in range\\n        uint128 liquidity;\\n    }\\n\\n    struct StepComputations {\\n        // the price at the beginning of the step\\n        uint160 sqrtPriceStartX96;\\n        // the next tick to swap to from the current tick in the swap direction\\n        int24 tickNext;\\n        // whether tickNext is initialized or not\\n        bool initialized;\\n        // sqrt(price) for the next tick (1/0)\\n        uint160 sqrtPriceNextX96;\\n        // how much is being swapped in in this step\\n        uint256 amountIn;\\n        // how much is being swapped out\\n        uint256 amountOut;\\n        // how much fee is being paid in\\n        uint256 feeAmount;\\n    }\\n\\n    struct SwapParams {\\n        uint24 fee;\\n        int24 tickSpacing;\\n        bool zeroForOne;\\n        int256 amountSpecified;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @dev Executes a swap against the state, and returns the amount deltas of the pool\\n    function swap(\\n        State storage self,\\n        SwapParams memory params\\n    ) internal returns (BalanceDelta result, uint256 feeForProtocol, uint256 feeForHook, SwapState memory state) {\\n        if (params.amountSpecified == 0) revert SwapAmountCannotBeZero();\\n\\n        Slot0 memory slot0Start = self.slot0;\\n        if (slot0Start.sqrtPriceX96 == 0) revert PoolNotInitialized();\\n        if (params.zeroForOne) {\\n            if (params.sqrtPriceLimitX96 >= slot0Start.sqrtPriceX96) {\\n                revert PriceLimitAlreadyExceeded(slot0Start.sqrtPriceX96, params.sqrtPriceLimitX96);\\n            }\\n            if (params.sqrtPriceLimitX96 <= TickMath.MIN_SQRT_RATIO) {\\n                revert PriceLimitOutOfBounds(params.sqrtPriceLimitX96);\\n            }\\n        } else {\\n            if (params.sqrtPriceLimitX96 <= slot0Start.sqrtPriceX96) {\\n                revert PriceLimitAlreadyExceeded(slot0Start.sqrtPriceX96, params.sqrtPriceLimitX96);\\n            }\\n            if (params.sqrtPriceLimitX96 >= TickMath.MAX_SQRT_RATIO) {\\n                revert PriceLimitOutOfBounds(params.sqrtPriceLimitX96);\\n            }\\n        }\\n\\n        SwapCache memory cache = SwapCache({\\n            liquidityStart: self.liquidity,\\n            protocolFee: params.zeroForOne\\n                ? (getSwapFee(slot0Start.protocolFees) % 64)\\n                : (getSwapFee(slot0Start.protocolFees) >> 6),\\n            hookFee: params.zeroForOne ? (getSwapFee(slot0Start.hookFees) % 64) : (getSwapFee(slot0Start.hookFees) >> 6)\\n        });\\n\\n        bool exactInput = params.amountSpecified > 0;\\n\\n        state = SwapState({\\n            amountSpecifiedRemaining: params.amountSpecified,\\n            amountCalculated: 0,\\n            sqrtPriceX96: slot0Start.sqrtPriceX96,\\n            tick: slot0Start.tick,\\n            feeGrowthGlobalX128: params.zeroForOne ? self.feeGrowthGlobal0X128 : self.feeGrowthGlobal1X128,\\n            liquidity: cache.liquidityStart\\n        });\\n\\n        StepComputations memory step;\\n        // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit\\n        while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != params.sqrtPriceLimitX96) {\\n            step.sqrtPriceStartX96 = state.sqrtPriceX96;\\n\\n            (step.tickNext, step.initialized) = self.tickBitmap.nextInitializedTickWithinOneWord(\\n                state.tick,\\n                params.tickSpacing,\\n                params.zeroForOne\\n            );\\n\\n            // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds\\n            if (step.tickNext < TickMath.MIN_TICK) {\\n                step.tickNext = TickMath.MIN_TICK;\\n            } else if (step.tickNext > TickMath.MAX_TICK) {\\n                step.tickNext = TickMath.MAX_TICK;\\n            }\\n\\n            // get the price for the next tick\\n            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);\\n\\n            // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted\\n            (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(\\n                state.sqrtPriceX96,\\n                (\\n                    params.zeroForOne\\n                        ? step.sqrtPriceNextX96 < params.sqrtPriceLimitX96\\n                        : step.sqrtPriceNextX96 > params.sqrtPriceLimitX96\\n                )\\n                    ? params.sqrtPriceLimitX96\\n                    : step.sqrtPriceNextX96,\\n                state.liquidity,\\n                state.amountSpecifiedRemaining,\\n                params.fee\\n            );\\n\\n            if (exactInput) {\\n                // safe because we test that amountSpecified > amountIn + feeAmount in SwapMath\\n                unchecked {\\n                    state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();\\n                }\\n                state.amountCalculated = state.amountCalculated - step.amountOut.toInt256();\\n            } else {\\n                unchecked {\\n                    state.amountSpecifiedRemaining += step.amountOut.toInt256();\\n                }\\n                state.amountCalculated = state.amountCalculated + (step.amountIn + step.feeAmount).toInt256();\\n            }\\n\\n            // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee\\n            if (cache.protocolFee > 0) {\\n                // A: calculate the amount of the fee that should go to the protocol\\n                uint256 delta = step.feeAmount / cache.protocolFee;\\n                // A: subtract it from the regular fee and add it to the protocol fee\\n                unchecked {\\n                    step.feeAmount -= delta;\\n                    feeForProtocol += delta;\\n                }\\n            }\\n\\n            if (cache.hookFee > 0) {\\n                // step.feeAmount has already been updated to account for the protocol fee\\n                uint256 delta = step.feeAmount / cache.hookFee;\\n                unchecked {\\n                    step.feeAmount -= delta;\\n                    feeForHook += delta;\\n                }\\n            }\\n\\n            // update global fee tracker\\n            if (state.liquidity > 0) {\\n                unchecked {\\n                    state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);\\n                }\\n            }\\n\\n            // shift tick if we reached the next price\\n            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {\\n                // if the tick is initialized, run the tick transition\\n                if (step.initialized) {\\n                    int128 liquidityNet = Pool.crossTick(\\n                        self,\\n                        step.tickNext,\\n                        (params.zeroForOne ? state.feeGrowthGlobalX128 : self.feeGrowthGlobal0X128),\\n                        (params.zeroForOne ? self.feeGrowthGlobal1X128 : state.feeGrowthGlobalX128)\\n                    );\\n                    // if we're moving leftward, we interpret liquidityNet as the opposite sign\\n                    // safe because liquidityNet cannot be type(int128).min\\n                    unchecked {\\n                        if (params.zeroForOne) liquidityNet = -liquidityNet;\\n                    }\\n\\n                    state.liquidity = liquidityNet < 0\\n                        ? state.liquidity - uint128(-liquidityNet)\\n                        : state.liquidity + uint128(liquidityNet);\\n                }\\n\\n                unchecked {\\n                    state.tick = params.zeroForOne ? step.tickNext - 1 : step.tickNext;\\n                }\\n            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\\n                // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\\n                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);\\n            }\\n        }\\n\\n        (self.slot0.sqrtPriceX96, self.slot0.tick) = (state.sqrtPriceX96, state.tick);\\n\\n        // update liquidity if it changed\\n        if (cache.liquidityStart != state.liquidity) self.liquidity = state.liquidity;\\n\\n        // update fee growth global\\n        if (params.zeroForOne) {\\n            self.feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;\\n        } else {\\n            self.feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;\\n        }\\n\\n        unchecked {\\n            if (params.zeroForOne == exactInput) {\\n                result = toBalanceDelta(\\n                    (params.amountSpecified - state.amountSpecifiedRemaining).toInt128(),\\n                    state.amountCalculated.toInt128()\\n                );\\n            } else {\\n                result = toBalanceDelta(\\n                    state.amountCalculated.toInt128(),\\n                    (params.amountSpecified - state.amountSpecifiedRemaining).toInt128()\\n                );\\n            }\\n        }\\n    }\\n\\n    /// @notice Donates the given amount of currency0 and currency1 to the pool\\n    function donate(State storage state, uint256 amount0, uint256 amount1) internal returns (BalanceDelta delta) {\\n        if (state.liquidity == 0) revert NoLiquidityToReceiveFees();\\n        delta = toBalanceDelta(amount0.toInt128(), amount1.toInt128());\\n        unchecked {\\n            if (amount0 > 0) {\\n                state.feeGrowthGlobal0X128 += FullMath.mulDiv(amount0, FixedPoint128.Q128, state.liquidity);\\n            }\\n            if (amount1 > 0) {\\n                state.feeGrowthGlobal1X128 += FullMath.mulDiv(amount1, FixedPoint128.Q128, state.liquidity);\\n            }\\n        }\\n    }\\n\\n    /// @notice Retrieves fee growth data\\n    /// @param self The Pool state struct\\n    /// @param tickLower The lower tick boundary of the position\\n    /// @param tickUpper The upper tick boundary of the position\\n    /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\\n    /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\\n    function getFeeGrowthInside(\\n        State storage self,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {\\n        TickInfo storage lower = self.ticks[tickLower];\\n        TickInfo storage upper = self.ticks[tickUpper];\\n        int24 tickCurrent = self.slot0.tick;\\n\\n        unchecked {\\n            if (tickCurrent < tickLower) {\\n                feeGrowthInside0X128 = lower.feeGrowthOutside0X128 - upper.feeGrowthOutside0X128;\\n                feeGrowthInside1X128 = lower.feeGrowthOutside1X128 - upper.feeGrowthOutside1X128;\\n            } else if (tickCurrent >= tickUpper) {\\n                feeGrowthInside0X128 = upper.feeGrowthOutside0X128 - lower.feeGrowthOutside0X128;\\n                feeGrowthInside1X128 = upper.feeGrowthOutside1X128 - lower.feeGrowthOutside1X128;\\n            } else {\\n                feeGrowthInside0X128 =\\n                    self.feeGrowthGlobal0X128 -\\n                    lower.feeGrowthOutside0X128 -\\n                    upper.feeGrowthOutside0X128;\\n                feeGrowthInside1X128 =\\n                    self.feeGrowthGlobal1X128 -\\n                    lower.feeGrowthOutside1X128 -\\n                    upper.feeGrowthOutside1X128;\\n            }\\n        }\\n    }\\n\\n    /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa\\n    /// @param self The mapping containing all tick information for initialized ticks\\n    /// @param tick The tick that will be updated\\n    /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)\\n    /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick\\n    /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa\\n    /// @return liquidityGrossAfter The total amount of  liquidity for all positions that references the tick after the update\\n    function updateTick(\\n        State storage self,\\n        int24 tick,\\n        int128 liquidityDelta,\\n        bool upper\\n    ) internal returns (bool flipped, uint128 liquidityGrossAfter) {\\n        TickInfo storage info = self.ticks[tick];\\n\\n        uint128 liquidityGrossBefore;\\n        int128 liquidityNetBefore;\\n        assembly {\\n            // load first slot of info which contains liquidityGross and liquidityNet packed\\n            // where the top 128 bits are liquidityNet and the bottom 128 bits are liquidityGross\\n            let liquidity := sload(info.slot)\\n            // slice off top 128 bits of liquidity (liquidityNet) to get just liquidityGross\\n            liquidityGrossBefore := shr(128, shl(128, liquidity))\\n            // shift right 128 bits to get just liquidityNet\\n            liquidityNetBefore := shr(128, liquidity)\\n        }\\n\\n        liquidityGrossAfter = liquidityDelta < 0\\n            ? liquidityGrossBefore - uint128(-liquidityDelta)\\n            : liquidityGrossBefore + uint128(liquidityDelta);\\n\\n        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\\n\\n        if (liquidityGrossBefore == 0) {\\n            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick\\n            if (tick <= self.slot0.tick) {\\n                info.feeGrowthOutside0X128 = self.feeGrowthGlobal0X128;\\n                info.feeGrowthOutside1X128 = self.feeGrowthGlobal1X128;\\n            }\\n        }\\n\\n        // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)\\n        int128 liquidityNet = upper ? liquidityNetBefore - liquidityDelta : liquidityNetBefore + liquidityDelta;\\n        assembly {\\n            // liquidityGrossAfter and liquidityNet are packed in the first slot of `info`\\n            // So we can store them with a single sstore by packing them ourselves first\\n            sstore(\\n                info.slot,\\n                // bitwise OR to pack liquidityGrossAfter and liquidityNet\\n                or(\\n                    // liquidityGross is in the low bits, upper bits are already 0\\n                    liquidityGrossAfter,\\n                    // shift liquidityNet to take the upper bits and lower bits get filled with 0\\n                    shl(128, liquidityNet)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @notice Derives max liquidity per tick from given tick spacing\\n    /// @dev Executed within the pool constructor\\n    /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`\\n    ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...\\n    /// @return The max liquidity per tick\\n    function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) {\\n        unchecked {\\n            return\\n                uint128(\\n                    (type(uint128).max * uint256(int256(tickSpacing))) /\\n                        uint256(int256(TickMath.MAX_TICK * 2 + tickSpacing))\\n                );\\n        }\\n    }\\n\\n    /// @notice Clears tick data\\n    /// @param self The mapping containing all initialized tick information for initialized ticks\\n    /// @param tick The tick that will be cleared\\n    function clearTick(State storage self, int24 tick) internal {\\n        delete self.ticks[tick];\\n    }\\n\\n    /// @notice Transitions to next tick as needed by price movement\\n    /// @param self The Pool state struct\\n    /// @param tick The destination tick of the transition\\n    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\\n    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\\n    /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)\\n    function crossTick(\\n        State storage self,\\n        int24 tick,\\n        uint256 feeGrowthGlobal0X128,\\n        uint256 feeGrowthGlobal1X128\\n    ) internal returns (int128 liquidityNet) {\\n        unchecked {\\n            TickInfo storage info = self.ticks[tick];\\n            info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;\\n            info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;\\n            liquidityNet = info.liquidityNet;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc56571cbc0f79e446fbb9ccf55e44908084a402b0e2b2d24b01812cb9aff6836\",\"license\":\"BUSL-1.1\"},\"@uniswap/v4-core/contracts/libraries/Position.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.20;\\n\\nimport {FullMath} from './FullMath.sol';\\nimport {FixedPoint128} from './FixedPoint128.sol';\\nimport 'hardhat/console.sol';\\n\\n/// @title Position\\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\\n/// @dev Positions store additional state for tracking fees owed to the position\\nlibrary Position {\\n    /// @notice Cannot update a position with no liquidity\\n    error CannotUpdateEmptyPosition();\\n\\n    // info stored for each user's position\\n    struct Info {\\n        // the amount of liquidity owned by this position\\n        uint128 liquidity;\\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\\n        uint256 feeGrowthInside0LastX128;\\n        uint256 feeGrowthInside1LastX128;\\n    }\\n\\n    /// @notice Returns the Info struct of a position, given an owner and position boundaries\\n    /// @param self The mapping containing all user positions\\n    /// @param owner The address of the position owner\\n    /// @param tickLower The lower tick boundary of the position\\n    /// @param tickUpper The upper tick boundary of the position\\n    /// @return position The position info struct of the given owners' position\\n    function get(\\n        mapping(bytes32 => Info) storage self,\\n        address owner,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) internal view returns (Position.Info storage position) {\\n        position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];\\n    }\\n\\n    /// @notice Credits accumulated fees to a user's position\\n    /// @param self The individual position to update\\n    /// @param liquidityDelta The change in pool liquidity as a result of the position update\\n    /// @param feeGrowthInside0X128 The all-time fee growth in currency0, per unit of liquidity, inside the position's tick boundaries\\n    /// @param feeGrowthInside1X128 The all-time fee growth in currency1, per unit of liquidity, inside the position's tick boundaries\\n    /// @return feesOwed0 The amount of currency0 owed to the position owner\\n    /// @return feesOwed1 The amount of currency1 owed to the position owner\\n    function update(\\n        Info storage self,\\n        int128 liquidityDelta,\\n        uint256 feeGrowthInside0X128,\\n        uint256 feeGrowthInside1X128\\n    ) internal returns (uint256 feesOwed0, uint256 feesOwed1) {\\n        Info memory _self = self;\\n\\n        uint128 liquidityNext;\\n        if (liquidityDelta == 0) {\\n            if (_self.liquidity == 0) revert CannotUpdateEmptyPosition(); // disallow pokes for 0 liquidity positions\\n            liquidityNext = _self.liquidity;\\n        } else {\\n            liquidityNext = liquidityDelta < 0\\n                ? _self.liquidity - uint128(-liquidityDelta)\\n                : _self.liquidity + uint128(liquidityDelta);\\n        }\\n        console.log(feeGrowthInside0X128, _self.feeGrowthInside0LastX128);\\n        // calculate accumulated fees. overflow in the subtraction of fee growth is expected\\n        unchecked {\\n            feesOwed0 = FullMath.mulDiv(\\n                feeGrowthInside0X128 - _self.feeGrowthInside0LastX128,\\n                _self.liquidity,\\n                FixedPoint128.Q128\\n            );\\n            feesOwed1 = FullMath.mulDiv(\\n                feeGrowthInside1X128 - _self.feeGrowthInside1LastX128,\\n                _self.liquidity,\\n                FixedPoint128.Q128\\n            );\\n        }\\n\\n        // update the position\\n        if (liquidityDelta != 0) self.liquidity = liquidityNext;\\n        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;\\n        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;\\n    }\\n}\\n\",\"keccak256\":\"0xff50e4cf7fe188c6fd5e4f069c357ef3f8d16cb836a2e8f57c6a92d15c9e522e\",\"license\":\"BUSL-1.1\"},\"@uniswap/v4-core/contracts/libraries/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title Safe casting methods\\n/// @notice Contains methods for safely casting between types\\nlibrary SafeCast {\\n    /// @notice Cast a uint256 to a uint160, revert on overflow\\n    /// @param y The uint256 to be downcasted\\n    /// @return z The downcasted integer, now type uint160\\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\\n        require((z = uint160(y)) == y);\\n    }\\n\\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\\n    /// @param y The int256 to be downcasted\\n    /// @return z The downcasted integer, now type int128\\n    function toInt128(int256 y) internal pure returns (int128 z) {\\n        require((z = int128(y)) == y);\\n    }\\n\\n    /// @notice Cast a uint256 to a int256, revert on overflow\\n    /// @param y The uint256 to be casted\\n    /// @return z The casted integer, now type int256\\n    function toInt256(uint256 y) internal pure returns (int256 z) {\\n        require(y <= uint256(type(int256).max));\\n        z = int256(y);\\n    }\\n\\n    /// @notice Cast a uint256 to a int128, revert on overflow\\n    /// @param y The uint256 to be downcasted\\n    /// @return z The downcasted integer, now type int128\\n    function toInt128(uint256 y) internal pure returns (int128 z) {\\n        require(y <= uint128(type(int128).max));\\n        z = int128(int256(y));\\n    }\\n}\\n\",\"keccak256\":\"0xb459cbf9f2cda4c38c11916e888cc2afbe4297c5ae6f50a0976eb83ed0dc9b25\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/SqrtPriceMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {SafeCast} from \\\"./SafeCast.sol\\\";\\n\\nimport {FullMath} from \\\"./FullMath.sol\\\";\\nimport {UnsafeMath} from \\\"./UnsafeMath.sol\\\";\\nimport {FixedPoint96} from \\\"./FixedPoint96.sol\\\";\\n\\n/// @title Functions based on Q64.96 sqrt price and liquidity\\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\\nlibrary SqrtPriceMath {\\n    using SafeCast for uint256;\\n\\n    /// @notice Gets the next sqrt price given a delta of currency0\\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\\n    /// price less in order to not send too much output.\\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the currency0 delta\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amount How much of currency0 to add or remove from virtual reserves\\n    /// @param add Whether to add or remove the amount of currency0\\n    /// @return The price after adding or removing amount, depending on add\\n    function getNextSqrtPriceFromAmount0RoundingUp(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\\n        internal\\n        pure\\n        returns (uint160)\\n    {\\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\\n        if (amount == 0) return sqrtPX96;\\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\\n\\n        if (add) {\\n            unchecked {\\n                uint256 product;\\n                if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\\n                    uint256 denominator = numerator1 + product;\\n                    if (denominator >= numerator1) {\\n                        // always fits in 160 bits\\n                        return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\\n                    }\\n                }\\n            }\\n            // denominator is checked for overflow\\n            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96) + amount));\\n        } else {\\n            unchecked {\\n                uint256 product;\\n                // if the product overflows, we know the denominator underflows\\n                // in addition, we must check that the denominator does not underflow\\n                require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);\\n                uint256 denominator = numerator1 - product;\\n                return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\\n            }\\n        }\\n    }\\n\\n    /// @notice Gets the next sqrt price given a delta of currency1\\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\\n    /// price less in order to not send too much output.\\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the currency1 delta\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amount How much of currency1 to add, or remove, from virtual reserves\\n    /// @param add Whether to add, or remove, the amount of currency1\\n    /// @return The price after adding or removing `amount`\\n    function getNextSqrtPriceFromAmount1RoundingDown(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\\n        internal\\n        pure\\n        returns (uint160)\\n    {\\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\\n        // in both cases, avoid a mulDiv for most inputs\\n        if (add) {\\n            uint256 quotient = (\\n                amount <= type(uint160).max\\n                    ? (amount << FixedPoint96.RESOLUTION) / liquidity\\n                    : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\\n            );\\n\\n            return (uint256(sqrtPX96) + quotient).toUint160();\\n        } else {\\n            uint256 quotient = (\\n                amount <= type(uint160).max\\n                    ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\\n                    : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\\n            );\\n\\n            require(sqrtPX96 > quotient);\\n            // always fits 160 bits\\n            return uint160(sqrtPX96 - quotient);\\n        }\\n    }\\n\\n    /// @notice Gets the next sqrt price given an input amount of currency0 or currency1\\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amountIn How much of currency0, or currency1, is being swapped in\\n    /// @param zeroForOne Whether the amount in is currency0 or currency1\\n    /// @return sqrtQX96 The price after adding the input amount to currency0 or currency1\\n    function getNextSqrtPriceFromInput(uint160 sqrtPX96, uint128 liquidity, uint256 amountIn, bool zeroForOne)\\n        internal\\n        pure\\n        returns (uint160 sqrtQX96)\\n    {\\n        require(sqrtPX96 > 0);\\n        require(liquidity > 0);\\n\\n        // round to make sure that we don't pass the target price\\n        return zeroForOne\\n            ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\\n            : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\\n    }\\n\\n    /// @notice Gets the next sqrt price given an output amount of currency0 or currency1\\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\\n    /// @param sqrtPX96 The starting price before accounting for the output amount\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amountOut How much of currency0, or currency1, is being swapped out\\n    /// @param zeroForOne Whether the amount out is currency0 or currency1\\n    /// @return sqrtQX96 The price after removing the output amount of currency0 or currency1\\n    function getNextSqrtPriceFromOutput(uint160 sqrtPX96, uint128 liquidity, uint256 amountOut, bool zeroForOne)\\n        internal\\n        pure\\n        returns (uint160 sqrtQX96)\\n    {\\n        require(sqrtPX96 > 0);\\n        require(liquidity > 0);\\n\\n        // round to make sure that we pass the target price\\n        return zeroForOne\\n            ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\\n            : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\\n    }\\n\\n    /// @notice Gets the amount0 delta between two prices\\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param roundUp Whether to round the amount up or down\\n    /// @return amount0 Amount of currency0 required to cover a position of size liquidity between the two passed prices\\n    function getAmount0Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp)\\n        internal\\n        pure\\n        returns (uint256 amount0)\\n    {\\n        unchecked {\\n            if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n            uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\\n            uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\\n\\n            require(sqrtRatioAX96 > 0);\\n\\n            return roundUp\\n                ? UnsafeMath.divRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96), sqrtRatioAX96)\\n                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;\\n        }\\n    }\\n\\n    /// @notice Gets the amount1 delta between two prices\\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param roundUp Whether to round the amount up, or down\\n    /// @return amount1 Amount of currency1 required to cover a position of size liquidity between the two passed prices\\n    function getAmount1Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp)\\n        internal\\n        pure\\n        returns (uint256 amount1)\\n    {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        return roundUp\\n            ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)\\n            : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\\n    }\\n\\n    /// @notice Helper that gets signed currency0 delta\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\\n    /// @return amount0 Amount of currency0 corresponding to the passed liquidityDelta between the two prices\\n    function getAmount0Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity)\\n        internal\\n        pure\\n        returns (int256 amount0)\\n    {\\n        unchecked {\\n            return liquidity < 0\\n                ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\\n                : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\\n        }\\n    }\\n\\n    /// @notice Helper that gets signed currency1 delta\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\\n    /// @return amount1 Amount of currency1 corresponding to the passed liquidityDelta between the two prices\\n    function getAmount1Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity)\\n        internal\\n        pure\\n        returns (int256 amount1)\\n    {\\n        unchecked {\\n            return liquidity < 0\\n                ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\\n                : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x62cb03c7ce6ce037c82fa74e5aabb2431d6b4ddbca1458efdabf5d6af9ca6f90\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/SwapMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {FullMath} from \\\"./FullMath.sol\\\";\\nimport {SqrtPriceMath} from \\\"./SqrtPriceMath.sol\\\";\\n\\n/// @title Computes the result of a swap within ticks\\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\\nlibrary SwapMath {\\n    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\\n    /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive\\n    /// @param sqrtRatioCurrentX96 The current sqrt price of the pool\\n    /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\\n    /// @param liquidity The usable liquidity\\n    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\\n    /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target\\n    /// @return amountIn The amount to be swapped in, of either currency0 or currency1, based on the direction of the swap\\n    /// @return amountOut The amount to be received, of either currency0 or currency1, based on the direction of the swap\\n    /// @return feeAmount The amount of input that will be taken as a fee\\n    function computeSwapStep(\\n        uint160 sqrtRatioCurrentX96,\\n        uint160 sqrtRatioTargetX96,\\n        uint128 liquidity,\\n        int256 amountRemaining,\\n        uint24 feePips\\n    ) internal pure returns (uint160 sqrtRatioNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount) {\\n        unchecked {\\n            bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;\\n            bool exactIn = amountRemaining >= 0;\\n\\n            if (exactIn) {\\n                uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);\\n                amountIn = zeroForOne\\n                    ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)\\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);\\n                if (amountRemainingLessFee >= amountIn) {\\n                    sqrtRatioNextX96 = sqrtRatioTargetX96;\\n                } else {\\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\\n                        sqrtRatioCurrentX96, liquidity, amountRemainingLessFee, zeroForOne\\n                    );\\n                }\\n            } else {\\n                amountOut = zeroForOne\\n                    ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)\\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);\\n                if (uint256(-amountRemaining) >= amountOut) {\\n                    sqrtRatioNextX96 = sqrtRatioTargetX96;\\n                } else {\\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(\\n                        sqrtRatioCurrentX96, liquidity, uint256(-amountRemaining), zeroForOne\\n                    );\\n                }\\n            }\\n\\n            bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;\\n\\n            // get the input/output amounts\\n            if (zeroForOne) {\\n                amountIn = max && exactIn\\n                    ? amountIn\\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);\\n                amountOut = max && !exactIn\\n                    ? amountOut\\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);\\n            } else {\\n                amountIn = max && exactIn\\n                    ? amountIn\\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);\\n                amountOut = max && !exactIn\\n                    ? amountOut\\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);\\n            }\\n\\n            // cap the output amount to not exceed the remaining output amount\\n            if (!exactIn && amountOut > uint256(-amountRemaining)) {\\n                amountOut = uint256(-amountRemaining);\\n            }\\n\\n            if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {\\n                // we didn't reach the target, so take the remainder of the maximum input as fee\\n                feeAmount = uint256(amountRemaining) - amountIn;\\n            } else {\\n                feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xac5b75b36ff928e88cbec828bdc9db03e681cc3b337d5d7f6be9fd617b3fef7f\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/TickBitmap.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {BitMath} from \\\"./BitMath.sol\\\";\\n\\n/// @title Packed tick initialized state library\\n/// @notice Stores a packed mapping of tick index to its initialized state\\n/// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.\\nlibrary TickBitmap {\\n    /// @notice Thrown when the tick is not enumerated by the tick spacing\\n    /// @param tick the invalid tick\\n    /// @param tickSpacing The tick spacing of the pool\\n    error TickMisaligned(int24 tick, int24 tickSpacing);\\n\\n    /// @notice Computes the position in the mapping where the initialized bit for a tick lives\\n    /// @param tick The tick for which to compute the position\\n    /// @return wordPos The key in the mapping containing the word in which the bit is stored\\n    /// @return bitPos The bit position in the word where the flag is stored\\n    function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {\\n        unchecked {\\n            wordPos = int16(tick >> 8);\\n            bitPos = uint8(int8(tick % 256));\\n        }\\n    }\\n\\n    /// @notice Flips the initialized state for a given tick from false to true, or vice versa\\n    /// @param self The mapping in which to flip the tick\\n    /// @param tick The tick to flip\\n    /// @param tickSpacing The spacing between usable ticks\\n    function flipTick(mapping(int16 => uint256) storage self, int24 tick, int24 tickSpacing) internal {\\n        unchecked {\\n            if (tick % tickSpacing != 0) revert TickMisaligned(tick, tickSpacing); // ensure that the tick is spaced\\n            (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);\\n            uint256 mask = 1 << bitPos;\\n            self[wordPos] ^= mask;\\n        }\\n    }\\n\\n    /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either\\n    /// to the left (less than or equal to) or right (greater than) of the given tick\\n    /// @param self The mapping in which to compute the next initialized tick\\n    /// @param tick The starting tick\\n    /// @param tickSpacing The spacing between usable ticks\\n    /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)\\n    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick\\n    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\\n    function nextInitializedTickWithinOneWord(\\n        mapping(int16 => uint256) storage self,\\n        int24 tick,\\n        int24 tickSpacing,\\n        bool lte\\n    ) internal view returns (int24 next, bool initialized) {\\n        unchecked {\\n            int24 compressed = tick / tickSpacing;\\n            if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity\\n\\n            if (lte) {\\n                (int16 wordPos, uint8 bitPos) = position(compressed);\\n                // all the 1s at or to the right of the current bitPos\\n                uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);\\n                uint256 masked = self[wordPos] & mask;\\n\\n                // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word\\n                initialized = masked != 0;\\n                // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\\n                next = initialized\\n                    ? (compressed - int24(uint24(bitPos - BitMath.mostSignificantBit(masked)))) * tickSpacing\\n                    : (compressed - int24(uint24(bitPos))) * tickSpacing;\\n            } else {\\n                // start from the word of the next tick, since the current tick state doesn't matter\\n                (int16 wordPos, uint8 bitPos) = position(compressed + 1);\\n                // all the 1s at or to the left of the bitPos\\n                uint256 mask = ~((1 << bitPos) - 1);\\n                uint256 masked = self[wordPos] & mask;\\n\\n                // if there are no initialized ticks to the left of the current tick, return leftmost in the word\\n                initialized = masked != 0;\\n                // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\\n                next = initialized\\n                    ? (compressed + 1 + int24(uint24(BitMath.leastSignificantBit(masked) - bitPos))) * tickSpacing\\n                    : (compressed + 1 + int24(uint24(type(uint8).max - bitPos))) * tickSpacing;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7cccb8dff4c76da872a827f1549dc44cdff384d123e77a5361a02a31902bf15c\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/TickMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    /// @notice Thrown when the tick passed to #getSqrtRatioAtTick is not between MIN_TICK and MAX_TICK\\n    error InvalidTick();\\n    /// @notice Thrown when the ratio passed to #getTickAtSqrtRatio does not correspond to a price between MIN_TICK and MAX_TICK\\n    error InvalidSqrtRatio();\\n\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Given a tickSpacing, compute the maximum usable tick\\n    function maxUsableTick(int24 tickSpacing) internal pure returns (int24) {\\n        unchecked {\\n            return (MAX_TICK / tickSpacing) * tickSpacing;\\n        }\\n    }\\n\\n    /// @notice Given a tickSpacing, compute the minimum usable tick\\n    function minUsableTick(int24 tickSpacing) internal pure returns (int24) {\\n        unchecked {\\n            return (MIN_TICK / tickSpacing) * tickSpacing;\\n        }\\n    }\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (currency1/currency0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n        unchecked {\\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n            if (absTick > uint256(int256(MAX_TICK))) revert InvalidTick();\\n\\n            uint256 ratio =\\n                absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n            if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n        }\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n        unchecked {\\n            // second inequality must be < because the price can never reach the price at the max tick\\n            if (sqrtPriceX96 < MIN_SQRT_RATIO || sqrtPriceX96 >= MAX_SQRT_RATIO) revert InvalidSqrtRatio();\\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n            uint256 r = ratio;\\n            uint256 msb = 0;\\n\\n            assembly {\\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(5, gt(r, 0xFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(4, gt(r, 0xFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(3, gt(r, 0xFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(2, gt(r, 0xF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(1, gt(r, 0x3))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := gt(r, 0x1)\\n                msb := or(msb, f)\\n            }\\n\\n            if (msb >= 128) r = ratio >> (msb - 127);\\n            else r = ratio << (127 - msb);\\n\\n            int256 log_2 = (int256(msb) - 128) << 64;\\n\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(63, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(62, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(61, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(60, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(59, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(58, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(57, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(56, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(55, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(54, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(53, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(52, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(51, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(50, f))\\n            }\\n\\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xadffea78a3eed37613b57766d87c0bdb9454d2df39de90d7a450e4a8b3207e56\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/UnsafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title Math functions that do not check inputs or outputs\\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\\nlibrary UnsafeMath {\\n    /// @notice Returns ceil(x / y)\\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\\n    /// @param x The dividend\\n    /// @param y The divisor\\n    /// @return z The quotient, ceil(x / y)\\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            assembly {\\n                z := add(div(x, y), gt(mod(x, y), 0))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2a8cb75af05f8557b698b089a0ab19e24279fffb7e87cddf5794404c7eaf1c69\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/types/BalanceDelta.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\ntype BalanceDelta is int256;\\n\\nusing {add as +, sub as -} for BalanceDelta global;\\nusing BalanceDeltaLibrary for BalanceDelta global;\\n\\nfunction toBalanceDelta(int128 _amount0, int128 _amount1) pure returns (BalanceDelta balanceDelta) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        balanceDelta :=\\n            or(shl(128, _amount0), and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff, _amount1))\\n    }\\n}\\n\\nfunction add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\\n    return toBalanceDelta(a.amount0() + b.amount0(), a.amount1() + b.amount1());\\n}\\n\\nfunction sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\\n    return toBalanceDelta(a.amount0() - b.amount0(), a.amount1() - b.amount1());\\n}\\n\\nlibrary BalanceDeltaLibrary {\\n    function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            _amount0 := shr(128, balanceDelta)\\n        }\\n    }\\n\\n    function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            _amount1 := balanceDelta\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb88fc16f2ae715bd796e5cdb77c2297117f18ce2183288ae4680d7f20cce5f85\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/types/Currency.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {IERC20Minimal} from \\\"../interfaces/external/IERC20Minimal.sol\\\";\\n\\ntype Currency is address;\\n\\nusing {greaterThan as >, lessThan as <, equals as ==} for Currency global;\\n\\nfunction equals(Currency currency, Currency other) pure returns (bool) {\\n    return Currency.unwrap(currency) == Currency.unwrap(other);\\n}\\n\\nfunction greaterThan(Currency currency, Currency other) pure returns (bool) {\\n    return Currency.unwrap(currency) > Currency.unwrap(other);\\n}\\n\\nfunction lessThan(Currency currency, Currency other) pure returns (bool) {\\n    return Currency.unwrap(currency) < Currency.unwrap(other);\\n}\\n\\n/// @title CurrencyLibrary\\n/// @dev This library allows for transferring and holding native tokens and ERC20 tokens\\nlibrary CurrencyLibrary {\\n    using CurrencyLibrary for Currency;\\n\\n    /// @notice Thrown when a native transfer fails\\n    error NativeTransferFailed();\\n\\n    /// @notice Thrown when an ERC20 transfer fails\\n    error ERC20TransferFailed();\\n\\n    Currency public constant NATIVE = Currency.wrap(address(0));\\n\\n    function transfer(Currency currency, address to, uint256 amount) internal {\\n        // implementation from\\n        // https://github.com/transmissions11/solmate/blob/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/SafeTransferLib.sol\\n\\n        bool success;\\n        if (currency.isNative()) {\\n            assembly {\\n                // Transfer the ETH and store if it succeeded or not.\\n                success := call(gas(), to, amount, 0, 0, 0, 0)\\n            }\\n\\n            if (!success) revert NativeTransferFailed();\\n        } else {\\n            assembly {\\n                // We'll write our calldata to this slot below, but restore it later.\\n                let memPointer := mload(0x40)\\n\\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\\n                mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n                mstore(4, to) // Append the \\\"to\\\" argument.\\n                mstore(36, amount) // Append the \\\"amount\\\" argument.\\n\\n                success :=\\n                    and(\\n                        // Set success to whether the call reverted, if not we check it either\\n                        // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                        or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                        // We use 68 because that's the total length of our calldata (4 + 32 * 2)\\n                        // Counterintuitively, this call() must be positioned after the or() in the\\n                        // surrounding and() because and() evaluates its arguments from right to left.\\n                        call(gas(), currency, 0, 0, 68, 0, 32)\\n                    )\\n\\n                mstore(0x60, 0) // Restore the zero slot to zero.\\n                mstore(0x40, memPointer) // Restore the memPointer.\\n            }\\n\\n            if (!success) revert ERC20TransferFailed();\\n        }\\n    }\\n\\n    function balanceOfSelf(Currency currency) internal view returns (uint256) {\\n        if (currency.isNative()) {\\n            return address(this).balance;\\n        } else {\\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(address(this));\\n        }\\n    }\\n\\n    function balanceOf(Currency currency, address owner) internal view returns (uint256) {\\n        if (currency.isNative()) {\\n            return owner.balance;\\n        } else {\\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(owner);\\n        }\\n    }\\n\\n    function isNative(Currency currency) internal pure returns (bool) {\\n        return Currency.unwrap(currency) == Currency.unwrap(NATIVE);\\n    }\\n\\n    function toId(Currency currency) internal pure returns (uint256) {\\n        return uint160(Currency.unwrap(currency));\\n    }\\n\\n    function fromId(uint256 id) internal pure returns (Currency) {\\n        return Currency.wrap(address(uint160(id)));\\n    }\\n}\\n\",\"keccak256\":\"0x008a7aeff6cdb7709a8e5893c9e9895a8a7ad594a0605586174e576b9888ff80\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/types/PoolId.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {PoolKey} from \\\"./PoolKey.sol\\\";\\n\\ntype PoolId is bytes32;\\n\\n/// @notice Library for computing the ID of a pool\\nlibrary PoolIdLibrary {\\n    function toId(PoolKey memory poolKey) internal pure returns (PoolId) {\\n        return PoolId.wrap(keccak256(abi.encode(poolKey)));\\n    }\\n}\\n\",\"keccak256\":\"0xd28e4ac2a0874b5372ab3873a263701ce625a840fc563c63d5ad8f7b3272f325\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/types/PoolKey.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.19;\\n\\nimport {Currency} from \\\"./Currency.sol\\\";\\nimport {IHooks} from \\\"../interfaces/IHooks.sol\\\";\\n\\n/// @notice Returns the key for identifying a pool\\nstruct PoolKey {\\n    /// @notice The lower currency of the pool, sorted numerically\\n    Currency currency0;\\n    /// @notice The higher currency of the pool, sorted numerically\\n    Currency currency1;\\n    /// @notice The pool swap fee, capped at 1_000_000. The upper 4 bits determine if the hook sets any fees.\\n    uint24 fee;\\n    /// @notice Ticks that involve positions must be a multiple of tick spacing\\n    int24 tickSpacing;\\n    /// @notice The hooks of the pool\\n    IHooks hooks;\\n}\\n\",\"keccak256\":\"0x4928c59e15db5af3bff68f4d9243ebe11a1dc4a4cbfa57c564db376086a902ce\",\"license\":\"GPL-2.0-or-later\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a06040523480156200001157600080fd5b50604051620061333803806200613383398101604081905262000034916200006d565b604080516020810190915260008152608082905262000053816200005b565b5050620001f8565b60056200006982826200012c565b5050565b6000602082840312156200008057600080fd5b5051919050565b634e487b7160e01b600052604160045260246000fd5b600181811c90821680620000b257607f821691505b602082108103620000d357634e487b7160e01b600052602260045260246000fd5b50919050565b601f8211156200012757600081815260208120601f850160051c81016020861015620001025750805b601f850160051c820191505b8181101562000123578281556001016200010e565b5050505b505050565b81516001600160401b0381111562000148576200014862000087565b62000160816200015984546200009d565b84620000d9565b602080601f8311600181146200019857600084156200017f5750858301515b600019600386901b1c1916600185901b17855562000123565b600085815260208120601f198616915b82811015620001c957888601518255948401946001909101908401620001a8565b5085821015620001e85787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b608051615f186200021b60003960008181611dca0152611e190152615f186000f3fe6080604052600436106101a25760003560e01c8062fdd58e146101ae57806301ffc9a7146101e1578063048d9c70146102115780630b0d9c091461025c5780630e89341c1461027e5780631e2eaeaf146102ab578063234266d7146102ca578063282076cc146102ea5780632d7713891461030a57806333aa955b146103475780634e1273f41461037f57806360460f06146103ac57806361ae449a146103cf578063695c5bf5146103ef5780636a256b291461040f57806381548319146104225780638161b8741461044257806384e41c5e1461046257806393c85a211461048957806397e8cd4e146104b6578063a22cb465146104e3578063a54b283114610503578063af440f821461053b578063b4c419391461055b578063b5217bb414610593578063c6c3bbe61461068a578063c815641c146106aa578063d68f4dd114610762578063e985e9c51461078f578063effd18c0146107d8578063f02de3b2146107f8578063f23a6e6114610818578063f242432a14610851578063f3cd914c14610871578063f8fcd15614610891578063fa6793d5146108dc57600080fd5b366101a957005b600080fd5b3480156101ba57600080fd5b506101ce6101c9366004614eec565b610915565b6040519081526020015b60405180910390f35b3480156101ed57600080fd5b506102016101fc366004614f2e565b6109b0565b60405190151581526020016101d8565b34801561021d57600080fd5b5061023161022c366004614f5d565b610a00565b6040805182516001600160801b031681526020808401519082015291810151908201526060016101d8565b34801561026857600080fd5b5061027c610277366004614fac565b610a80565b005b34801561028a57600080fd5b5061029e610299366004614fed565b610ad9565b6040516101d89190615056565b3480156102b757600080fd5b506101ce6102c6366004614fed565b5490565b3480156102d657600080fd5b506101ce6102e53660046151c2565b610b6d565b3480156102f657600080fd5b5061027c61030536600461522b565b610ce0565b34801561031657600080fd5b5061027c610325366004615247565b600280546001600160a01b0319166001600160a01b0392909216919091179055565b34801561035357600080fd5b50610367610362366004614f5d565b610d13565b6040516001600160801b0390911681526020016101d8565b34801561038b57600080fd5b5061039f61039a3660046152f8565b610d43565b6040516101d891906153c4565b3480156103b857600080fd5b506103c2617fff81565b6040516101d89190615408565b3480156103db57600080fd5b506101ce6103ea366004615416565b610e6c565b3480156103fb57600080fd5b506103c261040a3660046154b6565b611134565b6101ce61041d366004615247565b611372565b34801561042e57600080fd5b5061029e61043d366004615501565b6113da565b34801561044e57600080fd5b506101ce61045d366004614fac565b6114ed565b34801561046e57600080fd5b50610477600481565b60405160ff90911681526020016101d8565b34801561049557600080fd5b506101ce6104a4366004615247565b60086020526000908152604090205481565b3480156104c257600080fd5b506101ce6104d1366004615247565b60006020819052908152604090205481565b3480156104ef57600080fd5b5061027c6104fe366004615552565b61156c565b34801561050f57600080fd5b506101ce61051e366004615587565b600760209081526000928352604080842090915290825290205481565b34801561054757600080fd5b5061027c61055636600461522b565b61157b565b34801561056757600080fd5b506101ce610576366004615587565b600160209081526000928352604080842090915290825290205481565b34801561059f57600080fd5b506106276105ae366004614fed565b600960209081526000918252604091829020825160808101845281546001600160a01b0381168252600160a01b8104600290810b9483019490945262ffffff600160b81b8204811695830195909552600160d01b900490931660608401526001810154918101546003909101546001600160801b031684565b6040805185516001600160a01b0316815260208087015160020b908201528582015162ffffff9081169282019290925260609586015190911694810194909452608084019290925260a08301526001600160801b031660c082015260e0016101d8565b34801561069657600080fd5b5061027c6106a5366004614fac565b6115ae565b3480156106b657600080fd5b5061072a6106c5366004614fed565b600090815260096020908152604091829020825160808101845290546001600160a01b038116808352600160a01b820460020b93830184905262ffffff600160b81b83048116958401869052600160d01b909204909116606090920182905293919291565b604080516001600160a01b03909516855260029390930b602085015262ffffff918216928401929092521660608201526080016101d8565b34801561076e57600080fd5b5061078261077d366004614fed565b6115e7565b6040516101d891906155c0565b34801561079b57600080fd5b506102016107aa366004615587565b6001600160a01b03918216600090815260046020908152604080832093909416825291909152205460ff1690565b3480156107e457600080fd5b506101ce6107f3366004614fac565b6115f2565b34801561080457600080fd5b50600254610782906001600160a01b031681565b34801561082457600080fd5b506108386108333660046155d4565b611697565b6040516001600160e01b031990911681526020016101d8565b34801561085d57600080fd5b5061027c61086c366004615676565b6116b6565b34801561087d57600080fd5b506101ce61088c366004615734565b611749565b34801561089d57600080fd5b506006546108bc906001600160801b0380821691600160801b90041682565b604080516001600160801b039384168152929091166020830152016101d8565b3480156108e857600080fd5b506103676108f7366004614fed565b6000908152600960205260409020600301546001600160801b031690565b60006001600160a01b0383166109855760405162461bcd60e51b815260206004820152602a60248201527f455243313135353a2061646472657373207a65726f206973206e6f742061207660448201526930b634b21037bbb732b960b11b60648201526084015b60405180910390fd5b5060008181526003602090815260408083206001600160a01b03861684529091529020545b92915050565b60006001600160e01b03198216630f704b8f60e41b14806109e157506001600160e01b031982166303a24d0760e21b145b806109aa57506301ffc9a760e01b6001600160e01b03198316146109aa565b610a2d604051806060016040528060006001600160801b0316815260200160008152602001600081525090565b6000858152600960205260409020610a4a90600601858585611ab6565b6040805160608101825282546001600160801b03168152600183015460208201526002909201549082015290505b949350505050565b610a9283610a8d83611b0e565b611b28565b6001600160a01b03831660009081526008602052604081208054839290610aba9084906157d4565b90915550610ad490506001600160a01b0384168383611c10565b505050565b606060058054610ae8906157e7565b80601f0160208091040260200160405190810160405280929190818152602001828054610b14906157e7565b8015610b615780601f10610b3657610100808354040283529160200191610b61565b820191906000526020600020905b815481529060010190602001808311610b4457829003601f168201915b50505050509050919050565b6080850151600090600160991b1615610c13576080860151604051635b54587d60e11b808252916001600160a01b03169063b6a8b0fa90610bbc9033908b908b908b908b908b90600401615887565b6020604051808303816000875af1158015610bdb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bff91906158c5565b6001600160e01b03191614610c1357600080fd5b610c288585610c2189611cb9565b9190611cdd565b9050610c348682611d91565b6080860151600160981b1615610cd757608086015160405163e1b4af6960e01b808252916001600160a01b03169063e1b4af6990610c809033908b908b908b908b908b90600401615887565b6020604051808303816000875af1158015610c9f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cc391906158c5565b6001600160e01b03191614610cd757600080fd5b95945050505050565b6000610ceb82611db0565b90506000610cf883611eb1565b6000818152600960205260409020909150610ad49083611ee1565b6000848152600960205260408120610d3090600601858585611ab6565b546001600160801b031695945050505050565b60608151835114610da85760405162461bcd60e51b815260206004820152602960248201527f455243313135353a206163636f756e747320616e6420696473206c656e677468604482015268040dad2e6dac2e8c6d60bb1b606482015260840161097c565b600083516001600160401b03811115610dc357610dc3615069565b604051908082528060200260200182016040528015610dec578160200160208202803683370190505b50905060005b8451811015610e6457610e37858281518110610e1057610e106158e2565b6020026020010151858381518110610e2a57610e2a6158e2565b6020026020010151610915565b828281518110610e4957610e496158e2565b6020908102919091010152610e5d816158f8565b9050610df2565b509392505050565b60808401516000906001609d1b1615610f1057608085015160405163fe9a6f4560e01b808252916001600160a01b03169063fe9a6f4590610eb99033908a908a908a908a90600401615933565b6020604051808303816000875af1158015610ed8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610efc91906158c5565b6001600160e01b03191614610f1057600080fd5b6000610f1b86611eb1565b9050610f25614e64565b610f906040518060a00160405280336001600160a01b03168152602001886000015160020b8152602001886020015160020b8152602001610f698960400151611f2b565b600f0b815260608a015160020b602091820152600085815260099091526040902090611f41565b9093509050610f9f8784611d91565b805115610fc957805187516001600160a01b03166000908152602081905260409020805490910190555b602081015115610ffc57602080820151888201516001600160a01b03166000908152918290526040909120805490910190555b6040810151156110425760408082015160808901516001600160a01b039081166000908152600160209081528482208c5190931682529190915291909120805490910190555b60608101511561108757606081015160808801516001600160a01b039081166000908152600160209081526040808320828d0151909416835292905220805490910190555b60808701516001609c1b161561112a5760808701516040516330b7cdef60e01b808252916001600160a01b0316906330b7cdef906110d39033908c908c908a908d908d9060040161597e565b6020604051808303816000875af11580156110f2573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061111691906158c5565b6001600160e01b0319161461112a57600080fd5b5050949350505050565b6040840151600090620f4240620fffff9091161061115157600080fd5b6060850151617fff60029190910b131561116a57600080fd5b845160208601516001600160a01b039081169116111561118957600080fd5b6111ad856040015186608001516001600160a01b031661243d90919063ffffffff16565b6111b657600080fd5b60808501516001609f1b161561126b5760808501516040516301a206c160e51b808252916001600160a01b031690633440d820906112009033908a908a908a908a906004016159c4565b6020604051808303816000875af115801561121f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061124391906158c5565b6001600160e01b0319161461126b57604051631e048e1d60e01b815260040160405180910390fd5b600061127686611eb1565b9050600061128387611db0565b90506000611290886124be565b60008481526009602052604090209091506112ad90888484612591565b60808901519094506001609e1b161561136757608088015160405163a910f80f60e01b808252916001600160a01b03169063a910f80f906112fc9033908d908d908b908e908e90600401615a00565b6020604051808303816000875af115801561131b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061133f91906158c5565b6001600160e01b0319161461136757604051631e048e1d60e01b815260040160405180910390fd5b505050949350505050565b6001600160a01b038116600081815260086020526040812054909161139690612654565b6001600160a01b03841660009081526008602052604090208190556113bc9082906157d4565b91506113d4836113cb84611b0e565b610a8d90615a47565b50919050565b606061141b60063381546001600160801b03908116600080516020615ec383398151915281019290925582546001600160801b031916600190920116179055565b6040516355b148ff60e11b8152339063ab6291fe906114409086908690600401615a6a565b6000604051808303816000875af115801561145f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526114879190810190615a7e565b6006549091506001600160801b03166001036114c457600654600160801b90046001600160801b0316156114ba57600080fd5b60006006556109aa565b600680546001600160801b031981166001600160801b03918216600019019091161790556109aa565b600081156114fb5781611515565b6001600160a01b0383166000908152602081905260409020545b905080600080856001600160a01b03166001600160a01b03168152602001908152602001600020600082825461154b91906157d4565b9091555061156590506001600160a01b0384168583611c10565b9392505050565b6115773383836126e1565b5050565b6000611586826124be565b9050600061159383611eb1565b6000818152600960205260409020909150610ad490836127c1565b6115bb83610a8d83611b0e565b610ad4826115d1856001600160a01b031661280b565b8360405180602001604052806000815250612817565b60006109aa82612929565b60003382156116015782611628565b6001600160a01b038082166000908152600160209081526040808320938816835292905220545b91506001600160a01b0385161561163f5784611641565b805b6001600160a01b03808316600090815260016020908152604080832093891683529290529081208054929750849290919061167d9084906157d4565b90915550610e6490506001600160a01b0385168684611c10565b60006116a3858561293d565b5063f23a6e6160e01b9695505050505050565b6001600160a01b0385163314806116d257506116d285336107aa565b6117355760405162461bcd60e51b815260206004820152602e60248201527f455243313135353a2063616c6c6572206973206e6f7420746f6b656e206f776e60448201526d195c881bdc88185c1c1c9bdd995960921b606482015260840161097c565b6117428585858585612966565b5050505050565b60808401516000906001609b1b161561180e5760808501516040516315d7892d60e21b808252916001600160a01b03169063575e24b4906117969033908a908a908a908a90600401615b23565b6020604051808303816000875af11580156117b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117d991906158c5565b6001600160e01b0319161461180e576101a960405180604001604052806005815260200164082909090960db1b815250612b0f565b60408501516000906280000016156118b65785608001516001600160a01b0316632ab7a3e233888888886040518663ffffffff1660e01b8152600401611858959493929190615b23565b6020604051808303816000875af1158015611877573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061189b9190615b4e565b9050620f42408162ffffff16106118b157600080fd5b6118c2565b506040850151620fffff165b6000806118cd614e8c565b60006118d88a611eb1565b90506119486040518060a001604052808762ffffff1681526020018c6060015160020b81526020018b60000151151581526020018b6020015181526020018b604001516001600160a01b031681525060096000848152602001908152602001600020612b5590919063ffffffff16565b9298509095509350915061195c8a87611d91565b831561199d57836000808b60000151611979578c6020015161197c565b8c515b6001600160a01b031681526020810191909152604001600020805490910190555b82156119f65760808a01516001600160a01b031660009081526001602052604081208a518592906119d2578c602001516119d5565b8c515b6001600160a01b031681526020810191909152604001600020805490910190555b60808a01516001609a1b1615611aa95763b47b2fb160e01b6001600160e01b0319168a608001516001600160a01b031663b47b2fb1338d8d8b8e8e6040518763ffffffff1660e01b8152600401611a5296959493929190615b6b565b6020604051808303816000875af1158015611a71573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9591906158c5565b6001600160e01b03191614611aa957600080fd5b5050505050949350505050565b6040805160609490941b6001600160601b03191660208086019190915260e893841b60348601529190921b60378401528151601a818503018152603a9093018252825192810192909220600090815292909152902090565b600060016001607f1b03821115611b2457600080fd5b5090565b80600f0b600003611b37575050565b6000611b436006613332565b6001600160a01b038082166000908152600760209081526040808320938816835292905290812054919250611b7c600f85900b83615b96565b905080600003611bb257600680546000196001600160801b03600160801b80840482169290920181169091029116179055611be1565b81600003611be1576006805460016001600160801b03600160801b808404821692909201811690910291161790555b6001600160a01b0392831660009081526007602090815260408083209790951682529590955291909320555050565b6000611c24846001600160a01b031661335e565b15611c585760008060008085875af1905080611c5357604051633d2cec6f60e21b815260040160405180910390fd5b611cb3565b60405163a9059cbb60e01b6000528360045282602452602060006044600080895af13d15601f3d1160016000511416171691506000606052806040525080611cb357604051633c9fd93960e21b815260040160405180910390fd5b50505050565b600060096000611cc884611eb1565b81526020019081526020016000209050919050565b60038301546000906001600160801b03168103611d0d5760405163a74f97ab60e01b815260040160405180910390fd5b611d27611d1984611b0e565b611d2284611b0e565b61336b565b90508215611d5a576003840154611d4e908490600160801b906001600160801b031661337e565b60018501805490910190555b8115611565576003840154611d7f908390600160801b906001600160801b031661337e565b60028501805490910190559392505050565b8151611da190610a8d8360801c90565b6115778260200151610a8d8390565b600254600090819081906001600160a01b031615611eaa577f00000000000000000000000000000000000000000000000000000000000000005a1015611df557600080fd5b60025460405163d6ec458560e01b81526001600160a01b039091169063d6ec4585907f000000000000000000000000000000000000000000000000000000000000000090611e47908890600401615bbe565b6020604051808303818786fa93505050508015611e81575060408051601f3d908101601f19168201909252611e7e91810190615b4e565b60015b15611e9857925050610fff600c83901c8116915082165b611ea182613420565b611eaa81613420565b5050919050565b600081604051602001611ec49190615bbe565b604051602081830303815290604052805190602001209050919050565b81546001600160a01b0316600003611f0c5760405163486aa30760e01b815260040160405180910390fd5b815462ffffff909116600160b81b0262ffffff60b81b19909116179055565b80600f81900b8114611f3c57600080fd5b919050565b6000611f4b614e64565b83546001600160a01b0316600003611f765760405163486aa30760e01b815260040160405180910390fd5b611f8883602001518460400151613480565b6040805160c081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905281906060860151600f0b156120ff57611fdd87876020015188606001516000613514565b6001600160801b0316602083015215158152604086015160608701516120069189916001613514565b6001600160801b031660608084019190915290151560408301528601516000600f9190910b13156120be57600061204087608001516135ee565b9050806001600160801b031682602001516001600160801b0316111561207f57866020015160405163b8e3c38560e01b815260040161097c9190615408565b806001600160801b031682606001516001600160801b031611156120bc57866040015160405163b8e3c38560e01b815260040161097c9190615408565b505b8051156120dd57602086015160808701516120dd9160058a019161361c565b8060400151156120ff57604086015160808701516120ff9160058a019161361c565b61211287876020015188604001516136ae565b60a08301526080820152604080518082019091526002815261105360f21b60208281019190915287519088015161216292919061214e90615bcc565b62ffffff16896040015162ffffff16613765565b61217481608001518260a001516137ae565b6060860151608082015160a0830151885160208a015160408b01516121ac959493926121a49260068f0192611ab6565b9291906137f3565b809350819450505060008660600151600f0b12156121f1578051156121d9576121d987876020015161392a565b8060400151156121f1576121f187876040015161392a565b506060850151600f0b1561238f5760208501518654600291820b600160a01b90910490910b12156122655761225e8461225961225261224d6122368a6020015161394e565b6122438b6040015161394e565b8b60600151613c66565b611f2b565b600061336b565b613ca5565b935061238f565b60408501518654600291820b600160a01b90910490910b121561235957855460408601516122d9918691612259916122ae9161224d916001600160a01b0316906122439061394e565b611d2261224d6122c18b6020015161394e565b8c5460608d01516001600160a01b0390911690613ccf565b935060008560600151600f0b1261230c576060850151600387015461230791906001600160801b0316615be5565b612332565b846060015161231a90615a47565b600387015461233291906001600160801b0316615c0c565b6003870180546001600160801b0319166001600160801b039290921691909117905561238f565b61238c846122596000611d2261224d6123758b6020015161394e565b6123828c6040015161394e565b8c60600151613ccf565b93505b60008560600151600f0b1280156123b157508554600160d01b9004610fff1615155b15612414576123c08685613cfe565b9250612411846122596123d68660000151611b0e565b6123e38760400151611b0e565b6123ed9190615c2c565b6123fa8760200151611b0e565b6124078860600151611b0e565b611d229190615c2c565b93505b6124328461242d61242485611b0e565b611d2285611b0e565b613ec7565b935050509250929050565b60006001600160a01b0383161561249557600160981b836001600160a01b031610158061246e575062800000821615155b8061247d575062400000821615155b8061249057506220000082161515611565565b611565565b6280000082161580156124ab5750624000008216155b8015611565575050622000001615919050565b60808101516000906001600160a01b031615611f3c5781608001516001600160a01b0316635ae4ce58836040518263ffffffff1660e01b81526004016125049190615bbe565b602060405180830381865afa92505050801561253d575060408051601f3d908101601f1916820190925261253a91810190615b4e565b60015b15611f3c576040830151600090624000001661255a57600061255f565b62fff0005b6040850151909150600090622000001661257a57600061257e565b610fff5b61ffff1691909117919091169392505050565b83546000906001600160a01b0316156125bd57604051637983c05160e01b815260040160405180910390fd5b6125c684613ef4565b604080516080810182526001600160a01b0396909616808752600283900b602088015262ffffff958616918701829052938516606090960186905286546001600160b81b031916909317600160a01b948216949094029390931765ffffffffffff60b81b1916600160b81b90920262ffffff60d01b191691909117600160d01b909302929092179092555090565b6000612668826001600160a01b031661335e565b15612674575047919050565b6040516370a0823160e01b81526001600160a01b038316906370a08231906126a09030906004016155c0565b602060405180830381865afa1580156126bd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109aa9190615c59565b816001600160a01b0316836001600160a01b0316036127545760405162461bcd60e51b815260206004820152602960248201527f455243313135353a2073657474696e6720617070726f76616c20737461747573604482015268103337b91039b2b63360b91b606482015260840161097c565b6001600160a01b03838116600081815260046020908152604080832094871680845294825291829020805460ff191686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b81546001600160a01b03166000036127ec5760405163486aa30760e01b815260040160405180910390fd5b815462ffffff909116600160d01b0262ffffff60d01b19909116179055565b6001600160a01b031690565b6001600160a01b0384166128775760405162461bcd60e51b815260206004820152602160248201527f455243313135353a206d696e7420746f20746865207a65726f206164647265736044820152607360f81b606482015260840161097c565b336000612883856141c6565b90506000612890856141c6565b905060008681526003602090815260408083206001600160a01b038b168452909152812080548792906128c4908490615c72565b92505081905550866001600160a01b031660006001600160a01b0316846001600160a01b0316600080516020615ea38339815191528989604051612909929190615c85565b60405180910390a461292083600089898989614219565b50505050505050565b600080516020615ec3833981519152015490565b61295930612953846001600160a01b031661280b565b836143b5565b611577826113cb83611b0e565b6001600160a01b0384166129ca5760405162461bcd60e51b815260206004820152602560248201527f455243313135353a207472616e7366657220746f20746865207a65726f206164604482015264647265737360d81b606482015260840161097c565b3360006129d6856141c6565b905060006129e3856141c6565b905060008681526003602090815260408083206001600160a01b038c16845290915290205485811015612a6b5760405162461bcd60e51b815260206004820152602a60248201527f455243313135353a20696e73756666696369656e742062616c616e636520666f60448201526939103a3930b739b332b960b11b606482015260840161097c565b60008781526003602090815260408083206001600160a01b038d8116855292528083208985039055908a16825281208054889290612aaa908490615c72565b92505081905550876001600160a01b0316896001600160a01b0316856001600160a01b0316600080516020615ea38339815191528a8a604051612aee929190615c85565b60405180910390a4612b04848a8a8a8a8a614219565b505050505050505050565b612b5281604051602401612b239190615056565b60408051601f198184030181529190526020810180516001600160e01b031663104c13eb60e21b179052614525565b50565b6000806000612b62614e8c565b8460600151600003612b875760405163be8b850760e01b815260040160405180910390fd5b6040805160808101825287546001600160a01b038116808352600160a01b820460020b602084015262ffffff600160b81b8304811694840194909452600160d01b909104909216606082015290600003612bf45760405163486aa30760e01b815260040160405180910390fd5b856040015115612c875780600001516001600160a01b031686608001516001600160a01b031610612c415780516080870151604051637c9c6e8f60e01b815261097c929190600401615c93565b6401000276a36001600160a01b031686608001516001600160a01b031611612c82578560800151604051639e4d7cc760e01b815260040161097c91906155c0565b612d1a565b80600001516001600160a01b031686608001516001600160a01b031611612cca5780516080870151604051637c9c6e8f60e01b815261097c929190600401615c93565b73fffd8963efd1fc6a506488495d951d5263988d266001600160a01b031686608001516001600160a01b031610612d1a578560800151604051639e4d7cc760e01b815260040161097c91906155c0565b6040805160608101825260038901546001600160801b0316815290870151600091906020820190612d5557604084015160121c603f16612d6c565b604084810151600c1c610fff16612d6c9190615cc3565b61ffff1681526020018860400151612d8e57606084015160121c603f16612da7565b6060840151604090600c1c610fff16612da79190615cc3565b61ffff16815250905060008088606001511390506040518060c00160405280896060015181526020016000815260200184600001516001600160a01b03168152602001846020015160020b81526020018960400151612e0a578a60020154612e10565b8a600101545b815283516001600160801b03166020918201526040805160e0810182526000808252928101839052908101829052606081018290526080810182905260a0810182905260c08101919091529094505b845115801590612e89575088608001516001600160a01b031685604001516001600160a01b031614155b15613223576040808601516001600160a01b03168252606086015160208b0151918b0151612ebc9260058e01929161452e565b1515604083015260020b60208201819052620d89e7191315612ee757620d89e7196020820152612f1b565b612ef4620d89e719615bcc565b60020b816020015160020b1315612f1b57612f12620d89e719615bcc565b60020b60208201525b612f28816020015161394e565b6001600160a01b03166060820152604080860151908a0151612fab9190612f6b578a608001516001600160a01b031683606001516001600160a01b031611612f89565b8a608001516001600160a01b031683606001516001600160a01b0316105b612f97578260600151612f9d565b8a608001515b60a088015188518d51614670565b60c085015260a084015260808301526001600160a01b03166040860152811561300d57612fe18160c00151826080015101614862565b855103855260a0810151612ff490614862565b85602001516130039190615ce4565b6020860152613050565b61301a8160a00151614862565b855101855260c0810151608082015161303b9161303691615c72565b614862565b856020015161304a9190615b96565b60208601525b602083015161ffff161561308a576000836020015161ffff168260c001516130789190615d04565b60c08301805182900390529790970196505b604083015161ffff16156130c4576000836040015161ffff168260c001516130b29190615d04565b60c08301805182900390529690960195505b60a08501516001600160801b031615613103576130f78160c00151600160801b8760a001516001600160801b031661337e565b60808601805190910190525b80606001516001600160a01b031685604001516001600160a01b0316036131f0578060400151156131c757600061316f8b83602001518c6040015161314c578d60010154613152565b88608001515b8d60400151613165578960800151614878565b8e60020154614878565b905089604001511561317f576000035b600081600f0b1261319f57808660a0015161319a9190615be5565b6131b7565b6131a881615a47565b8660a001516131b79190615c0c565b6001600160801b031660a0870152505b88604001516131da5780602001516131e3565b60018160200151035b60020b6060860152612e5f565b80600001516001600160a01b031685604001516001600160a01b03161461321e576131e38560400151613ef4565b612e5f565b604085015160608601518b546001600160b81b031916600160a01b62ffffff909216919091026001600160a01b031916176001600160a01b03909116178a5560a085015183516001600160801b039182169116146132a25760a085015160038b0180546001600160801b0319166001600160801b039092169190911790555b8860400151156132bb57608085015160018b01556132c6565b608085015160028b01555b81151589604001511515036132ff576132f86132eb86600001518b6060015103611f2b565b611d228760200151611f2b565b9750613325565b61332261330f8660200151611f2b565b611d2287600001518c6060015103611f2b565b97505b5050505092959194509250565b80546000906109aa90613350906001906001600160801b0316615c0c565b6001600160801b0316612929565b6001600160a01b03161590565b6001600160801b031660809190911b1790565b600083830281600019858709828110838203039150508084116133a057600080fd5b806000036133b357508290049050611565565b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150509392505050565b61ffff811615612b52576000613437604083615cc3565b90506103ff600683901c1661ffff8216158015906134595750600461ffff8316105b80613476575061ffff8116158015906134765750600461ffff8216105b15610ad457600080fd5b8060020b8260020b126134b45760405163c4433ed560e01b8152600283810b600483015282900b602482015260440161097c565b620d89e719600283900b12156134df578160405163d5e2f7ab60e01b815260040161097c9190615408565b6134ec620d89e719615bcc565b60020b8160020b1315611577578060405163035aeeff60e31b815260040161097c9190615408565b600283900b6000908152600485016020526040812080548291906001600160801b0381169060801c600f87900b8413613556576135518783615be5565b613569565b61355f87615a47565b6135699083615c0c565b6001600160801b03808216159084168015919091141596509094506000036135b7578854600160a01b9004600290810b9089900b136135b7576001808a0154908401556002808a0154908401555b6000866135cd576135c88883615c2c565b6135d7565b6135d78883615d18565b90508060801b851784555050505094509492505050565b6000621b13d08201600290810b9083900b6001600160801b03028161361557613615615cad565b0492915050565b8060020b8260020b8161363157613631615cad565b0760020b1561366157604051636a6c79f360e11b8152600283810b600483015282900b602482015260440161097c565b6000806136828360020b8560020b8161367c5761367c615cad565b056148b4565b600191820b60009081526020979097526040909620805460ff9097169190911b90951890945550505050565b600282810b600081815260048601602052604080822085850b835290822087549294859492939192600160a01b909204900b9081121561370757816001015483600101540394508160020154836002015403935061375a565b8560020b8160020b1261373357826001015482600101540394508260020154826002015403935061375a565b81600101548360010154896001015403039450816002015483600201548960020154030393505b505050935093915050565b611cb38484848460405160240161377f9493929190615d45565b60408051601f198184030181529190526020810180516001600160e01b0316637c7a8d8f60e11b179052614525565b61157782826040516024016137c4929190615c85565b60408051601f198184030181529190526020810180516001600160e01b0316637b3338ad60e11b179052614525565b6040805160608101825285546001600160801b0316815260018601546020820152600286015491810191909152600090819081600f87900b81036138645781516001600160801b031660000361385c57604051632bbfae4960e21b815260040160405180910390fd5b508051613899565b600087600f0b1261388157815161387c908890615be5565b613896565b61388a87615a47565b82516138969190615c0c565b90505b6138a78683602001516137ae565b6138c98260200151870383600001516001600160801b0316600160801b61337e565b93506138ed8260400151860383600001516001600160801b0316600160801b61337e565b925086600f0b6000146139145787546001600160801b0319166001600160801b0382161788555b5050600186019390935560029094015591929050565b600290810b6000908152600490920160205260408220828155600181018390550155565b60008060008360020b12613965578260020b61396d565b8260020b6000035b9050620d89e8811115613993576040516333a3bdff60e21b815260040160405180910390fd5b6000816001166000036139aa57600160801b6139bc565b6ffffcb933bd6fad37aa2d162d1a5940015b6001600160881b0316905060028216156139e6576ffff97272373d413259a46990580e213a0260801c5b6004821615613a05576ffff2e50f5f656932ef12357cf3c7fdcc0260801c5b6008821615613a24576fffe5caca7e10e4e61c3624eaa0941cd00260801c5b6010821615613a43576fffcb9843d60f6159c9db58835c9266440260801c5b6020821615613a62576fff973b41fa98c081472e6896dfb254c00260801c5b6040821615613a81576fff2ea16466c96a3843ec78b326b528610260801c5b6080821615613aa0576ffe5dee046a99a2a811c461f1969c30530260801c5b610100821615613ac0576ffcbe86c7900a88aedcffc83b479aa3a40260801c5b610200821615613ae0576ff987a7253ac413176f2b074cf7815e540260801c5b610400821615613b00576ff3392b0822b70005940c7a398e4b70f30260801c5b610800821615613b20576fe7159475a2c29b7443b29c7fa6e889d90260801c5b611000821615613b40576fd097f3bdfd2022b8845ad8f792aa58250260801c5b612000821615613b60576fa9f746462d870fdf8a65dc1f90e061e50260801c5b614000821615613b80576f70d869a156d2a1b890bb3df62baf32f70260801c5b618000821615613ba0576f31be135f97d08fd981231505542fcfa60260801c5b62010000821615613bc1576f09aa508b5b7a84e1c677de54f3e99bc90260801c5b62020000821615613be1576e5d6af8dedb81196699c329225ee6040260801c5b62040000821615613c00576d2216e584f5fa1ea926041bedfe980260801c5b62080000821615613c1d576b048a170391f7dc42444e8fa20260801c5b60008460020b1315613c3e578060001981613c3a57613c3a615cad565b0490505b600160201b810615613c51576001613c54565b60005b60ff16602082901c0192505050919050565b60008082600f0b12613c8757613c8261303685858560016148c6565b610a78565b613c9a61303685858560000360006148c6565b600003949350505050565b6000611565613cb48360801c90565b613cbe8560801c90565b613cc89190615c2c565b8385612407565b60008082600f0b12613ceb57613c82613036858585600161497d565b613c9a613036858585600003600061497d565b613d06614e64565b6000613d128360801c90565b6040805160808101825286546001600160a01b0381168252600160a01b810460020b602083015262ffffff600160b81b82048116838501819052600160d01b9092049081166060840181905294955087949293600091610fff16613d769190615cc3565b9050603f600684901c166000613d916040610fff8616615cc3565b9050603f600685901c166000600f8a900b128015613db3575060008461ffff16115b15613ddf5761ffff8416613dc68a615a47565b613dd09190615d7d565b6001600160801b031660408b01525b600088600f0b128015613df6575060008361ffff16115b15613e225761ffff8316613e0989615a47565b613e139190615d7d565b6001600160801b031660608b01525b60008261ffff16118015613e3a575060008a60400151115b15613e6b578161ffff168a60400151613e539190615d04565b808b5260408b018051613e679083906157d4565b9052505b60008161ffff16118015613e83575060008a60600151115b15613eb8578061ffff168a60600151613e9c9190615d04565b60208b0181905260608b018051613eb49083906157d4565b9052505b50505050505050505092915050565b6000611565613ed68360801c90565b613ee08560801c90565b613eea9190615d18565b611d228486615d18565b60006401000276a36001600160a01b0383161080613f2f575073fffd8963efd1fc6a506488495d951d5263988d266001600160a01b03831610155b15613f4d5760405163015680db60e11b815260040160405180910390fd5b600160201b600160c01b03602083901b166001600160801b03811160071b81811c6001600160401b03811160061b90811c63ffffffff811160051b90811c61ffff811160041b90811c60ff8111600390811b91821c600f811160021b90811c918211600190811b92831c97908811961790941790921717909117171760808110613fdf57607f810383901c9150613fe9565b80607f0383901b91505b908002607f81811c60ff83811c9190911c800280831c81831c1c800280841c81841c1c800280851c81851c1c800280861c81861c1c800280871c81871c1c800280881c81881c1c800280891c81891c1c8002808a1c818a1c1c8002808b1c818b1c1c8002808c1c818c1c1c8002808d1c818d1c1c8002808e1c9c81901c9c909c1c80029c8d901c9e9d607f198f0160401b60c09190911c6001603f1b161760c19b909b1c6001603e1b169a909a1760c29990991c6001603d1b169890981760c39790971c6001603c1b169690961760c49590951c6001603b1b169490941760c59390931c6001603a1b169290921760c69190911c600160391b161760c79190911c600160381b161760c89190911c600160371b161760c99190911c600160361b161760ca9190911c600160351b161760cb9190911c600160341b161760cc9190911c600160331b161760cd9190911c600160321b1617693627a301d71055774c8581026f028f6481ab7f045a5af012a19d003aa9198101608090811d906fdb2df09e81959a81455e260799a0632f8301901d600281810b9083900b146141b757886001600160a01b031661419c8261394e565b6001600160a01b031611156141b157816141b9565b806141b9565b815b9998505050505050505050565b60408051600180825281830190925260609160009190602080830190803683370190505090508281600081518110614200576142006158e2565b602090810291909101015292915050565b505050505050565b6001600160a01b0384163b156142115760405163f23a6e6160e01b81526001600160a01b0385169063f23a6e619061425d9089908990889088908890600401615da3565b6020604051808303816000875af1925050508015614298575060408051601f3d908101601f19168201909252614295918101906158c5565b60015b614344576142a4615ddd565b806308c379a0036142dd57506142b8615df9565b806142c357506142df565b8060405162461bcd60e51b815260040161097c9190615056565b505b60405162461bcd60e51b815260206004820152603460248201527f455243313135353a207472616e7366657220746f206e6f6e2d455243313135356044820152732932b1b2b4bb32b91034b6b83632b6b2b73a32b960611b606482015260840161097c565b6001600160e01b0319811663f23a6e6160e01b146129205760405162461bcd60e51b815260206004820152602860248201527f455243313135353a204552433131353552656365697665722072656a656374656044820152676420746f6b656e7360c01b606482015260840161097c565b6001600160a01b0383166144175760405162461bcd60e51b815260206004820152602360248201527f455243313135353a206275726e2066726f6d20746865207a65726f206164647260448201526265737360e81b606482015260840161097c565b336000614423846141c6565b90506000614430846141c6565b6040805160208082018352600091829052888252600381528282206001600160a01b038b16835290522054909150848110156144ba5760405162461bcd60e51b8152602060048201526024808201527f455243313135353a206275726e20616d6f756e7420657863656564732062616c604482015263616e636560e01b606482015260840161097c565b60008681526003602090815260408083206001600160a01b03808c1680865291909352818420898603905590519091871690600080516020615ea383398151915290614509908b908b90615c85565b60405180910390a4604080516020810190915260009052612920565b612b52816149fb565b60008060008460020b8660020b8161454857614548615cad565b05905060008660020b12801561457557508460020b8660020b8161456e5761456e615cad565b0760020b15155b1561457f57600019015b83156145f257600080614591836148b4565b600182810b600090815260208d9052604090205460ff83169190911b800160001901908116801515975092945090925090856145d457888360ff168603026145e7565b886145de82614a1c565b840360ff168603025b965050505050614666565b600080614601836001016148b4565b600182810b600090815260208d9052604090205460ff83169190911b60001901199081168015159750929450909250908561464957888360ff0360ff1686600101010261465f565b888361465483614ab6565b0360ff168660010101025b9650505050505b5094509492505050565b60008080806001600160a01b03808916908a1610158187128015906146f55760006146a98989620f42400362ffffff16620f424061337e565b9050826146c2576146bd8c8c8c600161497d565b6146cf565b6146cf8b8d8c60016148c6565b95508581106146e0578a96506146ef565b6146ec8c8b8386614b9f565b96505b5061473f565b8161470c576147078b8b8b60006148c6565b614719565b6147198a8c8b600061497d565b935083886000031061472d5789955061473f565b61473c8b8a8a60000385614beb565b95505b6001600160a01b038a81169087161482156147a25780801561475e5750815b6147745761476f878d8c60016148c6565b614776565b855b9550808015614783575081155b61479957614794878d8c600061497d565b61479b565b845b94506147ec565b8080156147ac5750815b6147c2576147bd8c888c600161497d565b6147c4565b855b95508080156147d1575081155b6147e7576147e28c888c60006148c6565b6147e9565b845b94505b811580156147fc57508860000385115b15614808578860000394505b81801561482757508a6001600160a01b0316876001600160a01b031614155b15614836578589039350614853565b614850868962ffffff168a620f42400362ffffff16614c37565b93505b50505095509550955095915050565b60006001600160ff1b03821115611b2457600080fd5b600292830b600090815260049094016020526040909320600181018054909203909155908101805490920390915554600160801b9004600f0b90565b60020b600881901d9161010090910790565b6000836001600160a01b0316856001600160a01b031611156148e6579293925b600160601b600160e01b03606084901b166001600160a01b03868603811690871661491057600080fd5b8361494657866001600160a01b03166149338383896001600160a01b031661337e565b8161494057614940615cad565b04614972565b61497261495d8383896001600160a01b0316614c37565b886001600160a01b0316808204910615150190565b979650505050505050565b6000836001600160a01b0316856001600160a01b0316111561499d579293925b816149d1576149cc6001600160801b0384166149b98787615e82565b6001600160a01b0316600160601b61337e565b610cd7565b610cd76001600160801b0384166149e88787615e82565b6001600160a01b0316600160601b614c37565b60006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b6000808211614a2a57600080fd5b600160801b8210614a3d57608091821c91015b600160401b8210614a5057604091821c91015b600160201b8210614a6357602091821c91015b620100008210614a7557601091821c91015b6101008210614a8657600891821c91015b60108210614a9657600491821c91015b60048210614aa657600291821c91015b60028210611f3c57600101919050565b6000808211614ac457600080fd5b5060ff6001600160801b03821615614adf57607f1901614ae7565b608082901c91505b6001600160401b03821615614aff57603f1901614b07565b604082901c91505b63ffffffff821615614b1c57601f1901614b24565b602082901c91505b61ffff821615614b3757600f1901614b3f565b601082901c91505b60ff821615614b515760071901614b59565b600882901c91505b600f821615614b6b5760031901614b73565b600482901c91505b6003821615614b855760011901614b8d565b600282901c91505b6001821615611f3c5760001901919050565b600080856001600160a01b031611614bb657600080fd5b6000846001600160801b031611614bcc57600080fd5b81614bde576149cc8585856001614c77565b610cd78585856001614d5e565b600080856001600160a01b031611614c0257600080fd5b6000846001600160801b031611614c1857600080fd5b81614c2a576149cc8585856000614d5e565b610cd78585856000614c77565b6000614c4484848461337e565b905060008280614c5657614c56615cad565b8486091115611565576000198110614c6d57600080fd5b6001019392505050565b60008115614ce95760006001600160a01b03841115614cad57614ca884600160601b876001600160801b031661337e565b614cc4565b614cc46001600160801b038616606086901b615d04565b9050614ce1614cdc826001600160a01b038916615c72565b614e4e565b915050610a78565b60006001600160a01b03841115614d1757614d1284600160601b876001600160801b0316614c37565b614d34565b614d34606085901b6001600160801b038716808204910615150190565b905080866001600160a01b031611614d4b57600080fd5b614ce1816001600160a01b0388166157d4565b600082600003614d6f575083610a78565b600160601b600160e01b03606085901b168215614e01576001600160a01b03861684810290858281614da357614da3615cad565b0403614dd357818101828110614dd157614dc783896001600160a01b031683614c37565b9350505050610a78565b505b50614ce18185614dec6001600160a01b038a1683615d04565b614df69190615c72565b808204910615150190565b6001600160a01b03861684810290858281614e1e57614e1e615cad565b04148015614e2b57508082115b614e3457600080fd5b808203614dc7614cdc846001600160a01b038b1684614c37565b806001600160a01b0381168114611f3c57600080fd5b6040518060800160405280600081526020016000815260200160008152602001600081525090565b6040518060c00160405280600081526020016000815260200160006001600160a01b03168152602001600060020b81526020016000815260200160006001600160801b031681525090565b6001600160a01b0381168114612b5257600080fd5b60008060408385031215614eff57600080fd5b8235614f0a81614ed7565b946020939093013593505050565b6001600160e01b031981168114612b5257600080fd5b600060208284031215614f4057600080fd5b813561156581614f18565b8035600281900b8114611f3c57600080fd5b60008060008060808587031215614f7357600080fd5b843593506020850135614f8581614ed7565b9250614f9360408601614f4b565b9150614fa160608601614f4b565b905092959194509250565b600080600060608486031215614fc157600080fd5b8335614fcc81614ed7565b92506020840135614fdc81614ed7565b929592945050506040919091013590565b600060208284031215614fff57600080fd5b5035919050565b60005b83811015615021578181015183820152602001615009565b50506000910152565b60008151808452615042816020860160208601615006565b601f01601f19169290920160200192915050565b602081526000611565602083018461502a565b634e487b7160e01b600052604160045260246000fd5b606081016001600160401b038111828210171561509e5761509e615069565b60405250565b601f8201601f191681016001600160401b03811182821017156150c9576150c9615069565b6040525050565b62ffffff81168114612b5257600080fd5b600060a082840312156150f357600080fd5b60405160a081016001600160401b038111828210171561511557615115615069565b604052905080823561512681614ed7565b8152602083013561513681614ed7565b60208201526040830135615149816150d0565b604082015261515a60608401614f4b565b6060820152608083013561516d81614ed7565b6080919091015292915050565b60008083601f84011261518c57600080fd5b5081356001600160401b038111156151a357600080fd5b6020830191508360208285010111156151bb57600080fd5b9250929050565b600080600080600061010086880312156151db57600080fd5b6151e587876150e1565b945060a0860135935060c0860135925060e08601356001600160401b0381111561520e57600080fd5b61521a8882890161517a565b969995985093965092949392505050565b600060a0828403121561523d57600080fd5b61156583836150e1565b60006020828403121561525957600080fd5b813561156581614ed7565b60006001600160401b0382111561527d5761527d615069565b5060051b60200190565b600082601f83011261529857600080fd5b813560206152a582615264565b6040516152b282826150a4565b83815260059390931b85018201928281019150868411156152d257600080fd5b8286015b848110156152ed57803583529183019183016152d6565b509695505050505050565b6000806040838503121561530b57600080fd5b82356001600160401b038082111561532257600080fd5b818501915085601f83011261533657600080fd5b8135602061534382615264565b60405161535082826150a4565b83815260059390931b850182019282810191508984111561537057600080fd5b948201945b8386101561539757853561538881614ed7565b82529482019490820190615375565b965050860135925050808211156153ad57600080fd5b506153ba85828601615287565b9150509250929050565b6020808252825182820181905260009190848201906040850190845b818110156153fc578351835292840192918401916001016153e0565b50909695505050505050565b60029190910b815260200190565b60008060008084860361012081121561542e57600080fd5b61543887876150e1565b94506060609f198201121561544c57600080fd5b506040516154598161507f565b61546560a08701614f4b565b815261547360c08701614f4b565b602082015260e0860135604082015292506101008501356001600160401b0381111561549e57600080fd5b6154aa8782880161517a565b95989497509550505050565b60008060008060e085870312156154cc57600080fd5b6154d686866150e1565b935060a08501356154e681614ed7565b925060c08501356001600160401b0381111561549e57600080fd5b6000806020838503121561551457600080fd5b82356001600160401b0381111561552a57600080fd5b6155368582860161517a565b90969095509350505050565b80358015158114611f3c57600080fd5b6000806040838503121561556557600080fd5b823561557081614ed7565b915061557e60208401615542565b90509250929050565b6000806040838503121561559a57600080fd5b82356155a581614ed7565b915060208301356155b581614ed7565b809150509250929050565b6001600160a01b0391909116815260200190565b60008060008060008060a087890312156155ed57600080fd5b86356155f881614ed7565b9550602087013561560881614ed7565b9450604087013593506060870135925060808701356001600160401b0381111561563157600080fd5b61563d89828a0161517a565b979a9699509497509295939492505050565b60006001600160401b0382111561566857615668615069565b50601f01601f191660200190565b600080600080600060a0868803121561568e57600080fd5b853561569981614ed7565b945060208601356156a981614ed7565b9350604086013592506060860135915060808601356001600160401b038111156156d257600080fd5b8601601f810188136156e357600080fd5b80356156ee8161564f565b6040516156fb82826150a4565b8281528a602084860101111561571057600080fd5b82602085016020830137600060208483010152809450505050509295509295909350565b60008060008084860361012081121561574c57600080fd5b61575687876150e1565b94506060609f198201121561576a57600080fd5b506040516157778161507f565b61578360a08701615542565b815260c0860135602082015260e086013561579d81614ed7565b604082015292506101008501356001600160401b0381111561549e57600080fd5b634e487b7160e01b600052601160045260246000fd5b818103818111156109aa576109aa6157be565b600181811c908216806157fb57607f821691505b6020821081036113d457634e487b7160e01b600052602260045260246000fd5b80516001600160a01b03908116835260208083015182169084015260408083015162ffffff169084015260608083015160020b9084015260809182015116910152565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6001600160a01b038716815260006101206158a5602084018961581b565b8660c08401528560e0840152806101008401526141b9818401858761585e565b6000602082840312156158d757600080fd5b815161156581614f18565b634e487b7160e01b600052603260045260246000fd5b60006001820161590a5761590a6157be565b5060010190565b805160020b8252602081015160020b6020830152604081015160408301525050565b6001600160a01b03861681526000610140615951602084018861581b565b61595e60c0840187615911565b80610120840152615972818401858761585e565b98975050505050505050565b6001600160a01b0387168152600061016061599c602084018961581b565b6159a960c0840188615911565b85610120840152806101408401526141b9818401858761585e565b6001600160a01b038681168252600090610100906159e5602085018961581b565b861660c084015260e08301819052615972818401858761585e565b6001600160a01b03878116825260009061012090615a21602085018a61581b565b80881660c0850152508560020b60e0840152806101008401526141b9818401858761585e565b6000600f82900b6001607f1b8101615a6157615a616157be565b60000392915050565b602081526000610a7860208301848661585e565b600060208284031215615a9057600080fd5b81516001600160401b03811115615aa657600080fd5b8201601f81018413615ab757600080fd5b8051615ac28161564f565b604051615acf82826150a4565b828152866020848601011115615ae457600080fd5b615af5836020830160208701615006565b9695505050505050565b805115158252602080820151908301526040908101516001600160a01b0316910152565b6001600160a01b03861681526000610140615b41602084018861581b565b61595e60c0840187615aff565b600060208284031215615b6057600080fd5b8151611565816150d0565b6001600160a01b03871681526000610160615b89602084018961581b565b6159a960c0840188615aff565b8082018281126000831280158216821582161715615bb657615bb66157be565b505092915050565b60a081016109aa828461581b565b60008160020b627fffff198103615a6157615a616157be565b6001600160801b03818116838216019080821115615c0557615c056157be565b5092915050565b6001600160801b03828116828216039080821115615c0557615c056157be565b600f81810b9083900b0160016001607f1b03811360016001607f1b0319821217156109aa576109aa6157be565b600060208284031215615c6b57600080fd5b5051919050565b808201808211156109aa576109aa6157be565b918252602082015260400190565b6001600160a01b0392831681529116602082015260400190565b634e487b7160e01b600052601260045260246000fd5b600061ffff80841680615cd857615cd8615cad565b92169190910692915050565b8181036000831280158383131683831282161715615c0557615c056157be565b600082615d1357615d13615cad565b500490565b600f82810b9082900b0360016001607f1b0319811260016001607f1b03821317156109aa576109aa6157be565b608081526000615d58608083018761502a565b6001600160a01b03959095166020830152506040810192909252606090910152919050565b60006001600160801b0383811680615d9757615d97615cad565b92169190910492915050565b6001600160a01b03868116825285166020820152604081018490526060810183905260a0608082018190526000906149729083018461502a565b600060033d1115615df65760046000803e5060005160e01c5b90565b600060443d1015615e075790565b6040516003193d81016004833e81513d6001600160401b038083116024840183101715615e3657505050505090565b8285019150815181811115615e4e5750505050505090565b843d8701016020828501011115615e685750505050505090565b615e77602082860101876150a4565b509095945050505050565b6001600160a01b03828116828216039080821115615c0557615c056157be56fec3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62760a9a962ae3d184e99c0483cf5684fb3170f47116ca4f445c50209da4f4f906a264697066735822122089418c4eb0cdd0285ac4648f2de407dc7fd03db4664ccdc8956f0008ec8db92d64736f6c63430008140033",
  "deployedBytecode": "0x6080604052600436106101a25760003560e01c8062fdd58e146101ae57806301ffc9a7146101e1578063048d9c70146102115780630b0d9c091461025c5780630e89341c1461027e5780631e2eaeaf146102ab578063234266d7146102ca578063282076cc146102ea5780632d7713891461030a57806333aa955b146103475780634e1273f41461037f57806360460f06146103ac57806361ae449a146103cf578063695c5bf5146103ef5780636a256b291461040f57806381548319146104225780638161b8741461044257806384e41c5e1461046257806393c85a211461048957806397e8cd4e146104b6578063a22cb465146104e3578063a54b283114610503578063af440f821461053b578063b4c419391461055b578063b5217bb414610593578063c6c3bbe61461068a578063c815641c146106aa578063d68f4dd114610762578063e985e9c51461078f578063effd18c0146107d8578063f02de3b2146107f8578063f23a6e6114610818578063f242432a14610851578063f3cd914c14610871578063f8fcd15614610891578063fa6793d5146108dc57600080fd5b366101a957005b600080fd5b3480156101ba57600080fd5b506101ce6101c9366004614eec565b610915565b6040519081526020015b60405180910390f35b3480156101ed57600080fd5b506102016101fc366004614f2e565b6109b0565b60405190151581526020016101d8565b34801561021d57600080fd5b5061023161022c366004614f5d565b610a00565b6040805182516001600160801b031681526020808401519082015291810151908201526060016101d8565b34801561026857600080fd5b5061027c610277366004614fac565b610a80565b005b34801561028a57600080fd5b5061029e610299366004614fed565b610ad9565b6040516101d89190615056565b3480156102b757600080fd5b506101ce6102c6366004614fed565b5490565b3480156102d657600080fd5b506101ce6102e53660046151c2565b610b6d565b3480156102f657600080fd5b5061027c61030536600461522b565b610ce0565b34801561031657600080fd5b5061027c610325366004615247565b600280546001600160a01b0319166001600160a01b0392909216919091179055565b34801561035357600080fd5b50610367610362366004614f5d565b610d13565b6040516001600160801b0390911681526020016101d8565b34801561038b57600080fd5b5061039f61039a3660046152f8565b610d43565b6040516101d891906153c4565b3480156103b857600080fd5b506103c2617fff81565b6040516101d89190615408565b3480156103db57600080fd5b506101ce6103ea366004615416565b610e6c565b3480156103fb57600080fd5b506103c261040a3660046154b6565b611134565b6101ce61041d366004615247565b611372565b34801561042e57600080fd5b5061029e61043d366004615501565b6113da565b34801561044e57600080fd5b506101ce61045d366004614fac565b6114ed565b34801561046e57600080fd5b50610477600481565b60405160ff90911681526020016101d8565b34801561049557600080fd5b506101ce6104a4366004615247565b60086020526000908152604090205481565b3480156104c257600080fd5b506101ce6104d1366004615247565b60006020819052908152604090205481565b3480156104ef57600080fd5b5061027c6104fe366004615552565b61156c565b34801561050f57600080fd5b506101ce61051e366004615587565b600760209081526000928352604080842090915290825290205481565b34801561054757600080fd5b5061027c61055636600461522b565b61157b565b34801561056757600080fd5b506101ce610576366004615587565b600160209081526000928352604080842090915290825290205481565b34801561059f57600080fd5b506106276105ae366004614fed565b600960209081526000918252604091829020825160808101845281546001600160a01b0381168252600160a01b8104600290810b9483019490945262ffffff600160b81b8204811695830195909552600160d01b900490931660608401526001810154918101546003909101546001600160801b031684565b6040805185516001600160a01b0316815260208087015160020b908201528582015162ffffff9081169282019290925260609586015190911694810194909452608084019290925260a08301526001600160801b031660c082015260e0016101d8565b34801561069657600080fd5b5061027c6106a5366004614fac565b6115ae565b3480156106b657600080fd5b5061072a6106c5366004614fed565b600090815260096020908152604091829020825160808101845290546001600160a01b038116808352600160a01b820460020b93830184905262ffffff600160b81b83048116958401869052600160d01b909204909116606090920182905293919291565b604080516001600160a01b03909516855260029390930b602085015262ffffff918216928401929092521660608201526080016101d8565b34801561076e57600080fd5b5061078261077d366004614fed565b6115e7565b6040516101d891906155c0565b34801561079b57600080fd5b506102016107aa366004615587565b6001600160a01b03918216600090815260046020908152604080832093909416825291909152205460ff1690565b3480156107e457600080fd5b506101ce6107f3366004614fac565b6115f2565b34801561080457600080fd5b50600254610782906001600160a01b031681565b34801561082457600080fd5b506108386108333660046155d4565b611697565b6040516001600160e01b031990911681526020016101d8565b34801561085d57600080fd5b5061027c61086c366004615676565b6116b6565b34801561087d57600080fd5b506101ce61088c366004615734565b611749565b34801561089d57600080fd5b506006546108bc906001600160801b0380821691600160801b90041682565b604080516001600160801b039384168152929091166020830152016101d8565b3480156108e857600080fd5b506103676108f7366004614fed565b6000908152600960205260409020600301546001600160801b031690565b60006001600160a01b0383166109855760405162461bcd60e51b815260206004820152602a60248201527f455243313135353a2061646472657373207a65726f206973206e6f742061207660448201526930b634b21037bbb732b960b11b60648201526084015b60405180910390fd5b5060008181526003602090815260408083206001600160a01b03861684529091529020545b92915050565b60006001600160e01b03198216630f704b8f60e41b14806109e157506001600160e01b031982166303a24d0760e21b145b806109aa57506301ffc9a760e01b6001600160e01b03198316146109aa565b610a2d604051806060016040528060006001600160801b0316815260200160008152602001600081525090565b6000858152600960205260409020610a4a90600601858585611ab6565b6040805160608101825282546001600160801b03168152600183015460208201526002909201549082015290505b949350505050565b610a9283610a8d83611b0e565b611b28565b6001600160a01b03831660009081526008602052604081208054839290610aba9084906157d4565b90915550610ad490506001600160a01b0384168383611c10565b505050565b606060058054610ae8906157e7565b80601f0160208091040260200160405190810160405280929190818152602001828054610b14906157e7565b8015610b615780601f10610b3657610100808354040283529160200191610b61565b820191906000526020600020905b815481529060010190602001808311610b4457829003601f168201915b50505050509050919050565b6080850151600090600160991b1615610c13576080860151604051635b54587d60e11b808252916001600160a01b03169063b6a8b0fa90610bbc9033908b908b908b908b908b90600401615887565b6020604051808303816000875af1158015610bdb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bff91906158c5565b6001600160e01b03191614610c1357600080fd5b610c288585610c2189611cb9565b9190611cdd565b9050610c348682611d91565b6080860151600160981b1615610cd757608086015160405163e1b4af6960e01b808252916001600160a01b03169063e1b4af6990610c809033908b908b908b908b908b90600401615887565b6020604051808303816000875af1158015610c9f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cc391906158c5565b6001600160e01b03191614610cd757600080fd5b95945050505050565b6000610ceb82611db0565b90506000610cf883611eb1565b6000818152600960205260409020909150610ad49083611ee1565b6000848152600960205260408120610d3090600601858585611ab6565b546001600160801b031695945050505050565b60608151835114610da85760405162461bcd60e51b815260206004820152602960248201527f455243313135353a206163636f756e747320616e6420696473206c656e677468604482015268040dad2e6dac2e8c6d60bb1b606482015260840161097c565b600083516001600160401b03811115610dc357610dc3615069565b604051908082528060200260200182016040528015610dec578160200160208202803683370190505b50905060005b8451811015610e6457610e37858281518110610e1057610e106158e2565b6020026020010151858381518110610e2a57610e2a6158e2565b6020026020010151610915565b828281518110610e4957610e496158e2565b6020908102919091010152610e5d816158f8565b9050610df2565b509392505050565b60808401516000906001609d1b1615610f1057608085015160405163fe9a6f4560e01b808252916001600160a01b03169063fe9a6f4590610eb99033908a908a908a908a90600401615933565b6020604051808303816000875af1158015610ed8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610efc91906158c5565b6001600160e01b03191614610f1057600080fd5b6000610f1b86611eb1565b9050610f25614e64565b610f906040518060a00160405280336001600160a01b03168152602001886000015160020b8152602001886020015160020b8152602001610f698960400151611f2b565b600f0b815260608a015160020b602091820152600085815260099091526040902090611f41565b9093509050610f9f8784611d91565b805115610fc957805187516001600160a01b03166000908152602081905260409020805490910190555b602081015115610ffc57602080820151888201516001600160a01b03166000908152918290526040909120805490910190555b6040810151156110425760408082015160808901516001600160a01b039081166000908152600160209081528482208c5190931682529190915291909120805490910190555b60608101511561108757606081015160808801516001600160a01b039081166000908152600160209081526040808320828d0151909416835292905220805490910190555b60808701516001609c1b161561112a5760808701516040516330b7cdef60e01b808252916001600160a01b0316906330b7cdef906110d39033908c908c908a908d908d9060040161597e565b6020604051808303816000875af11580156110f2573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061111691906158c5565b6001600160e01b0319161461112a57600080fd5b5050949350505050565b6040840151600090620f4240620fffff9091161061115157600080fd5b6060850151617fff60029190910b131561116a57600080fd5b845160208601516001600160a01b039081169116111561118957600080fd5b6111ad856040015186608001516001600160a01b031661243d90919063ffffffff16565b6111b657600080fd5b60808501516001609f1b161561126b5760808501516040516301a206c160e51b808252916001600160a01b031690633440d820906112009033908a908a908a908a906004016159c4565b6020604051808303816000875af115801561121f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061124391906158c5565b6001600160e01b0319161461126b57604051631e048e1d60e01b815260040160405180910390fd5b600061127686611eb1565b9050600061128387611db0565b90506000611290886124be565b60008481526009602052604090209091506112ad90888484612591565b60808901519094506001609e1b161561136757608088015160405163a910f80f60e01b808252916001600160a01b03169063a910f80f906112fc9033908d908d908b908e908e90600401615a00565b6020604051808303816000875af115801561131b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061133f91906158c5565b6001600160e01b0319161461136757604051631e048e1d60e01b815260040160405180910390fd5b505050949350505050565b6001600160a01b038116600081815260086020526040812054909161139690612654565b6001600160a01b03841660009081526008602052604090208190556113bc9082906157d4565b91506113d4836113cb84611b0e565b610a8d90615a47565b50919050565b606061141b60063381546001600160801b03908116600080516020615ec383398151915281019290925582546001600160801b031916600190920116179055565b6040516355b148ff60e11b8152339063ab6291fe906114409086908690600401615a6a565b6000604051808303816000875af115801561145f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526114879190810190615a7e565b6006549091506001600160801b03166001036114c457600654600160801b90046001600160801b0316156114ba57600080fd5b60006006556109aa565b600680546001600160801b031981166001600160801b03918216600019019091161790556109aa565b600081156114fb5781611515565b6001600160a01b0383166000908152602081905260409020545b905080600080856001600160a01b03166001600160a01b03168152602001908152602001600020600082825461154b91906157d4565b9091555061156590506001600160a01b0384168583611c10565b9392505050565b6115773383836126e1565b5050565b6000611586826124be565b9050600061159383611eb1565b6000818152600960205260409020909150610ad490836127c1565b6115bb83610a8d83611b0e565b610ad4826115d1856001600160a01b031661280b565b8360405180602001604052806000815250612817565b60006109aa82612929565b60003382156116015782611628565b6001600160a01b038082166000908152600160209081526040808320938816835292905220545b91506001600160a01b0385161561163f5784611641565b805b6001600160a01b03808316600090815260016020908152604080832093891683529290529081208054929750849290919061167d9084906157d4565b90915550610e6490506001600160a01b0385168684611c10565b60006116a3858561293d565b5063f23a6e6160e01b9695505050505050565b6001600160a01b0385163314806116d257506116d285336107aa565b6117355760405162461bcd60e51b815260206004820152602e60248201527f455243313135353a2063616c6c6572206973206e6f7420746f6b656e206f776e60448201526d195c881bdc88185c1c1c9bdd995960921b606482015260840161097c565b6117428585858585612966565b5050505050565b60808401516000906001609b1b161561180e5760808501516040516315d7892d60e21b808252916001600160a01b03169063575e24b4906117969033908a908a908a908a90600401615b23565b6020604051808303816000875af11580156117b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117d991906158c5565b6001600160e01b0319161461180e576101a960405180604001604052806005815260200164082909090960db1b815250612b0f565b60408501516000906280000016156118b65785608001516001600160a01b0316632ab7a3e233888888886040518663ffffffff1660e01b8152600401611858959493929190615b23565b6020604051808303816000875af1158015611877573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061189b9190615b4e565b9050620f42408162ffffff16106118b157600080fd5b6118c2565b506040850151620fffff165b6000806118cd614e8c565b60006118d88a611eb1565b90506119486040518060a001604052808762ffffff1681526020018c6060015160020b81526020018b60000151151581526020018b6020015181526020018b604001516001600160a01b031681525060096000848152602001908152602001600020612b5590919063ffffffff16565b9298509095509350915061195c8a87611d91565b831561199d57836000808b60000151611979578c6020015161197c565b8c515b6001600160a01b031681526020810191909152604001600020805490910190555b82156119f65760808a01516001600160a01b031660009081526001602052604081208a518592906119d2578c602001516119d5565b8c515b6001600160a01b031681526020810191909152604001600020805490910190555b60808a01516001609a1b1615611aa95763b47b2fb160e01b6001600160e01b0319168a608001516001600160a01b031663b47b2fb1338d8d8b8e8e6040518763ffffffff1660e01b8152600401611a5296959493929190615b6b565b6020604051808303816000875af1158015611a71573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9591906158c5565b6001600160e01b03191614611aa957600080fd5b5050505050949350505050565b6040805160609490941b6001600160601b03191660208086019190915260e893841b60348601529190921b60378401528151601a818503018152603a9093018252825192810192909220600090815292909152902090565b600060016001607f1b03821115611b2457600080fd5b5090565b80600f0b600003611b37575050565b6000611b436006613332565b6001600160a01b038082166000908152600760209081526040808320938816835292905290812054919250611b7c600f85900b83615b96565b905080600003611bb257600680546000196001600160801b03600160801b80840482169290920181169091029116179055611be1565b81600003611be1576006805460016001600160801b03600160801b808404821692909201811690910291161790555b6001600160a01b0392831660009081526007602090815260408083209790951682529590955291909320555050565b6000611c24846001600160a01b031661335e565b15611c585760008060008085875af1905080611c5357604051633d2cec6f60e21b815260040160405180910390fd5b611cb3565b60405163a9059cbb60e01b6000528360045282602452602060006044600080895af13d15601f3d1160016000511416171691506000606052806040525080611cb357604051633c9fd93960e21b815260040160405180910390fd5b50505050565b600060096000611cc884611eb1565b81526020019081526020016000209050919050565b60038301546000906001600160801b03168103611d0d5760405163a74f97ab60e01b815260040160405180910390fd5b611d27611d1984611b0e565b611d2284611b0e565b61336b565b90508215611d5a576003840154611d4e908490600160801b906001600160801b031661337e565b60018501805490910190555b8115611565576003840154611d7f908390600160801b906001600160801b031661337e565b60028501805490910190559392505050565b8151611da190610a8d8360801c90565b6115778260200151610a8d8390565b600254600090819081906001600160a01b031615611eaa577f00000000000000000000000000000000000000000000000000000000000000005a1015611df557600080fd5b60025460405163d6ec458560e01b81526001600160a01b039091169063d6ec4585907f000000000000000000000000000000000000000000000000000000000000000090611e47908890600401615bbe565b6020604051808303818786fa93505050508015611e81575060408051601f3d908101601f19168201909252611e7e91810190615b4e565b60015b15611e9857925050610fff600c83901c8116915082165b611ea182613420565b611eaa81613420565b5050919050565b600081604051602001611ec49190615bbe565b604051602081830303815290604052805190602001209050919050565b81546001600160a01b0316600003611f0c5760405163486aa30760e01b815260040160405180910390fd5b815462ffffff909116600160b81b0262ffffff60b81b19909116179055565b80600f81900b8114611f3c57600080fd5b919050565b6000611f4b614e64565b83546001600160a01b0316600003611f765760405163486aa30760e01b815260040160405180910390fd5b611f8883602001518460400151613480565b6040805160c081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905281906060860151600f0b156120ff57611fdd87876020015188606001516000613514565b6001600160801b0316602083015215158152604086015160608701516120069189916001613514565b6001600160801b031660608084019190915290151560408301528601516000600f9190910b13156120be57600061204087608001516135ee565b9050806001600160801b031682602001516001600160801b0316111561207f57866020015160405163b8e3c38560e01b815260040161097c9190615408565b806001600160801b031682606001516001600160801b031611156120bc57866040015160405163b8e3c38560e01b815260040161097c9190615408565b505b8051156120dd57602086015160808701516120dd9160058a019161361c565b8060400151156120ff57604086015160808701516120ff9160058a019161361c565b61211287876020015188604001516136ae565b60a08301526080820152604080518082019091526002815261105360f21b60208281019190915287519088015161216292919061214e90615bcc565b62ffffff16896040015162ffffff16613765565b61217481608001518260a001516137ae565b6060860151608082015160a0830151885160208a015160408b01516121ac959493926121a49260068f0192611ab6565b9291906137f3565b809350819450505060008660600151600f0b12156121f1578051156121d9576121d987876020015161392a565b8060400151156121f1576121f187876040015161392a565b506060850151600f0b1561238f5760208501518654600291820b600160a01b90910490910b12156122655761225e8461225961225261224d6122368a6020015161394e565b6122438b6040015161394e565b8b60600151613c66565b611f2b565b600061336b565b613ca5565b935061238f565b60408501518654600291820b600160a01b90910490910b121561235957855460408601516122d9918691612259916122ae9161224d916001600160a01b0316906122439061394e565b611d2261224d6122c18b6020015161394e565b8c5460608d01516001600160a01b0390911690613ccf565b935060008560600151600f0b1261230c576060850151600387015461230791906001600160801b0316615be5565b612332565b846060015161231a90615a47565b600387015461233291906001600160801b0316615c0c565b6003870180546001600160801b0319166001600160801b039290921691909117905561238f565b61238c846122596000611d2261224d6123758b6020015161394e565b6123828c6040015161394e565b8c60600151613ccf565b93505b60008560600151600f0b1280156123b157508554600160d01b9004610fff1615155b15612414576123c08685613cfe565b9250612411846122596123d68660000151611b0e565b6123e38760400151611b0e565b6123ed9190615c2c565b6123fa8760200151611b0e565b6124078860600151611b0e565b611d229190615c2c565b93505b6124328461242d61242485611b0e565b611d2285611b0e565b613ec7565b935050509250929050565b60006001600160a01b0383161561249557600160981b836001600160a01b031610158061246e575062800000821615155b8061247d575062400000821615155b8061249057506220000082161515611565565b611565565b6280000082161580156124ab5750624000008216155b8015611565575050622000001615919050565b60808101516000906001600160a01b031615611f3c5781608001516001600160a01b0316635ae4ce58836040518263ffffffff1660e01b81526004016125049190615bbe565b602060405180830381865afa92505050801561253d575060408051601f3d908101601f1916820190925261253a91810190615b4e565b60015b15611f3c576040830151600090624000001661255a57600061255f565b62fff0005b6040850151909150600090622000001661257a57600061257e565b610fff5b61ffff1691909117919091169392505050565b83546000906001600160a01b0316156125bd57604051637983c05160e01b815260040160405180910390fd5b6125c684613ef4565b604080516080810182526001600160a01b0396909616808752600283900b602088015262ffffff958616918701829052938516606090960186905286546001600160b81b031916909317600160a01b948216949094029390931765ffffffffffff60b81b1916600160b81b90920262ffffff60d01b191691909117600160d01b909302929092179092555090565b6000612668826001600160a01b031661335e565b15612674575047919050565b6040516370a0823160e01b81526001600160a01b038316906370a08231906126a09030906004016155c0565b602060405180830381865afa1580156126bd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109aa9190615c59565b816001600160a01b0316836001600160a01b0316036127545760405162461bcd60e51b815260206004820152602960248201527f455243313135353a2073657474696e6720617070726f76616c20737461747573604482015268103337b91039b2b63360b91b606482015260840161097c565b6001600160a01b03838116600081815260046020908152604080832094871680845294825291829020805460ff191686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b81546001600160a01b03166000036127ec5760405163486aa30760e01b815260040160405180910390fd5b815462ffffff909116600160d01b0262ffffff60d01b19909116179055565b6001600160a01b031690565b6001600160a01b0384166128775760405162461bcd60e51b815260206004820152602160248201527f455243313135353a206d696e7420746f20746865207a65726f206164647265736044820152607360f81b606482015260840161097c565b336000612883856141c6565b90506000612890856141c6565b905060008681526003602090815260408083206001600160a01b038b168452909152812080548792906128c4908490615c72565b92505081905550866001600160a01b031660006001600160a01b0316846001600160a01b0316600080516020615ea38339815191528989604051612909929190615c85565b60405180910390a461292083600089898989614219565b50505050505050565b600080516020615ec3833981519152015490565b61295930612953846001600160a01b031661280b565b836143b5565b611577826113cb83611b0e565b6001600160a01b0384166129ca5760405162461bcd60e51b815260206004820152602560248201527f455243313135353a207472616e7366657220746f20746865207a65726f206164604482015264647265737360d81b606482015260840161097c565b3360006129d6856141c6565b905060006129e3856141c6565b905060008681526003602090815260408083206001600160a01b038c16845290915290205485811015612a6b5760405162461bcd60e51b815260206004820152602a60248201527f455243313135353a20696e73756666696369656e742062616c616e636520666f60448201526939103a3930b739b332b960b11b606482015260840161097c565b60008781526003602090815260408083206001600160a01b038d8116855292528083208985039055908a16825281208054889290612aaa908490615c72565b92505081905550876001600160a01b0316896001600160a01b0316856001600160a01b0316600080516020615ea38339815191528a8a604051612aee929190615c85565b60405180910390a4612b04848a8a8a8a8a614219565b505050505050505050565b612b5281604051602401612b239190615056565b60408051601f198184030181529190526020810180516001600160e01b031663104c13eb60e21b179052614525565b50565b6000806000612b62614e8c565b8460600151600003612b875760405163be8b850760e01b815260040160405180910390fd5b6040805160808101825287546001600160a01b038116808352600160a01b820460020b602084015262ffffff600160b81b8304811694840194909452600160d01b909104909216606082015290600003612bf45760405163486aa30760e01b815260040160405180910390fd5b856040015115612c875780600001516001600160a01b031686608001516001600160a01b031610612c415780516080870151604051637c9c6e8f60e01b815261097c929190600401615c93565b6401000276a36001600160a01b031686608001516001600160a01b031611612c82578560800151604051639e4d7cc760e01b815260040161097c91906155c0565b612d1a565b80600001516001600160a01b031686608001516001600160a01b031611612cca5780516080870151604051637c9c6e8f60e01b815261097c929190600401615c93565b73fffd8963efd1fc6a506488495d951d5263988d266001600160a01b031686608001516001600160a01b031610612d1a578560800151604051639e4d7cc760e01b815260040161097c91906155c0565b6040805160608101825260038901546001600160801b0316815290870151600091906020820190612d5557604084015160121c603f16612d6c565b604084810151600c1c610fff16612d6c9190615cc3565b61ffff1681526020018860400151612d8e57606084015160121c603f16612da7565b6060840151604090600c1c610fff16612da79190615cc3565b61ffff16815250905060008088606001511390506040518060c00160405280896060015181526020016000815260200184600001516001600160a01b03168152602001846020015160020b81526020018960400151612e0a578a60020154612e10565b8a600101545b815283516001600160801b03166020918201526040805160e0810182526000808252928101839052908101829052606081018290526080810182905260a0810182905260c08101919091529094505b845115801590612e89575088608001516001600160a01b031685604001516001600160a01b031614155b15613223576040808601516001600160a01b03168252606086015160208b0151918b0151612ebc9260058e01929161452e565b1515604083015260020b60208201819052620d89e7191315612ee757620d89e7196020820152612f1b565b612ef4620d89e719615bcc565b60020b816020015160020b1315612f1b57612f12620d89e719615bcc565b60020b60208201525b612f28816020015161394e565b6001600160a01b03166060820152604080860151908a0151612fab9190612f6b578a608001516001600160a01b031683606001516001600160a01b031611612f89565b8a608001516001600160a01b031683606001516001600160a01b0316105b612f97578260600151612f9d565b8a608001515b60a088015188518d51614670565b60c085015260a084015260808301526001600160a01b03166040860152811561300d57612fe18160c00151826080015101614862565b855103855260a0810151612ff490614862565b85602001516130039190615ce4565b6020860152613050565b61301a8160a00151614862565b855101855260c0810151608082015161303b9161303691615c72565b614862565b856020015161304a9190615b96565b60208601525b602083015161ffff161561308a576000836020015161ffff168260c001516130789190615d04565b60c08301805182900390529790970196505b604083015161ffff16156130c4576000836040015161ffff168260c001516130b29190615d04565b60c08301805182900390529690960195505b60a08501516001600160801b031615613103576130f78160c00151600160801b8760a001516001600160801b031661337e565b60808601805190910190525b80606001516001600160a01b031685604001516001600160a01b0316036131f0578060400151156131c757600061316f8b83602001518c6040015161314c578d60010154613152565b88608001515b8d60400151613165578960800151614878565b8e60020154614878565b905089604001511561317f576000035b600081600f0b1261319f57808660a0015161319a9190615be5565b6131b7565b6131a881615a47565b8660a001516131b79190615c0c565b6001600160801b031660a0870152505b88604001516131da5780602001516131e3565b60018160200151035b60020b6060860152612e5f565b80600001516001600160a01b031685604001516001600160a01b03161461321e576131e38560400151613ef4565b612e5f565b604085015160608601518b546001600160b81b031916600160a01b62ffffff909216919091026001600160a01b031916176001600160a01b03909116178a5560a085015183516001600160801b039182169116146132a25760a085015160038b0180546001600160801b0319166001600160801b039092169190911790555b8860400151156132bb57608085015160018b01556132c6565b608085015160028b01555b81151589604001511515036132ff576132f86132eb86600001518b6060015103611f2b565b611d228760200151611f2b565b9750613325565b61332261330f8660200151611f2b565b611d2287600001518c6060015103611f2b565b97505b5050505092959194509250565b80546000906109aa90613350906001906001600160801b0316615c0c565b6001600160801b0316612929565b6001600160a01b03161590565b6001600160801b031660809190911b1790565b600083830281600019858709828110838203039150508084116133a057600080fd5b806000036133b357508290049050611565565b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150509392505050565b61ffff811615612b52576000613437604083615cc3565b90506103ff600683901c1661ffff8216158015906134595750600461ffff8316105b80613476575061ffff8116158015906134765750600461ffff8216105b15610ad457600080fd5b8060020b8260020b126134b45760405163c4433ed560e01b8152600283810b600483015282900b602482015260440161097c565b620d89e719600283900b12156134df578160405163d5e2f7ab60e01b815260040161097c9190615408565b6134ec620d89e719615bcc565b60020b8160020b1315611577578060405163035aeeff60e31b815260040161097c9190615408565b600283900b6000908152600485016020526040812080548291906001600160801b0381169060801c600f87900b8413613556576135518783615be5565b613569565b61355f87615a47565b6135699083615c0c565b6001600160801b03808216159084168015919091141596509094506000036135b7578854600160a01b9004600290810b9089900b136135b7576001808a0154908401556002808a0154908401555b6000866135cd576135c88883615c2c565b6135d7565b6135d78883615d18565b90508060801b851784555050505094509492505050565b6000621b13d08201600290810b9083900b6001600160801b03028161361557613615615cad565b0492915050565b8060020b8260020b8161363157613631615cad565b0760020b1561366157604051636a6c79f360e11b8152600283810b600483015282900b602482015260440161097c565b6000806136828360020b8560020b8161367c5761367c615cad565b056148b4565b600191820b60009081526020979097526040909620805460ff9097169190911b90951890945550505050565b600282810b600081815260048601602052604080822085850b835290822087549294859492939192600160a01b909204900b9081121561370757816001015483600101540394508160020154836002015403935061375a565b8560020b8160020b1261373357826001015482600101540394508260020154826002015403935061375a565b81600101548360010154896001015403039450816002015483600201548960020154030393505b505050935093915050565b611cb38484848460405160240161377f9493929190615d45565b60408051601f198184030181529190526020810180516001600160e01b0316637c7a8d8f60e11b179052614525565b61157782826040516024016137c4929190615c85565b60408051601f198184030181529190526020810180516001600160e01b0316637b3338ad60e11b179052614525565b6040805160608101825285546001600160801b0316815260018601546020820152600286015491810191909152600090819081600f87900b81036138645781516001600160801b031660000361385c57604051632bbfae4960e21b815260040160405180910390fd5b508051613899565b600087600f0b1261388157815161387c908890615be5565b613896565b61388a87615a47565b82516138969190615c0c565b90505b6138a78683602001516137ae565b6138c98260200151870383600001516001600160801b0316600160801b61337e565b93506138ed8260400151860383600001516001600160801b0316600160801b61337e565b925086600f0b6000146139145787546001600160801b0319166001600160801b0382161788555b5050600186019390935560029094015591929050565b600290810b6000908152600490920160205260408220828155600181018390550155565b60008060008360020b12613965578260020b61396d565b8260020b6000035b9050620d89e8811115613993576040516333a3bdff60e21b815260040160405180910390fd5b6000816001166000036139aa57600160801b6139bc565b6ffffcb933bd6fad37aa2d162d1a5940015b6001600160881b0316905060028216156139e6576ffff97272373d413259a46990580e213a0260801c5b6004821615613a05576ffff2e50f5f656932ef12357cf3c7fdcc0260801c5b6008821615613a24576fffe5caca7e10e4e61c3624eaa0941cd00260801c5b6010821615613a43576fffcb9843d60f6159c9db58835c9266440260801c5b6020821615613a62576fff973b41fa98c081472e6896dfb254c00260801c5b6040821615613a81576fff2ea16466c96a3843ec78b326b528610260801c5b6080821615613aa0576ffe5dee046a99a2a811c461f1969c30530260801c5b610100821615613ac0576ffcbe86c7900a88aedcffc83b479aa3a40260801c5b610200821615613ae0576ff987a7253ac413176f2b074cf7815e540260801c5b610400821615613b00576ff3392b0822b70005940c7a398e4b70f30260801c5b610800821615613b20576fe7159475a2c29b7443b29c7fa6e889d90260801c5b611000821615613b40576fd097f3bdfd2022b8845ad8f792aa58250260801c5b612000821615613b60576fa9f746462d870fdf8a65dc1f90e061e50260801c5b614000821615613b80576f70d869a156d2a1b890bb3df62baf32f70260801c5b618000821615613ba0576f31be135f97d08fd981231505542fcfa60260801c5b62010000821615613bc1576f09aa508b5b7a84e1c677de54f3e99bc90260801c5b62020000821615613be1576e5d6af8dedb81196699c329225ee6040260801c5b62040000821615613c00576d2216e584f5fa1ea926041bedfe980260801c5b62080000821615613c1d576b048a170391f7dc42444e8fa20260801c5b60008460020b1315613c3e578060001981613c3a57613c3a615cad565b0490505b600160201b810615613c51576001613c54565b60005b60ff16602082901c0192505050919050565b60008082600f0b12613c8757613c8261303685858560016148c6565b610a78565b613c9a61303685858560000360006148c6565b600003949350505050565b6000611565613cb48360801c90565b613cbe8560801c90565b613cc89190615c2c565b8385612407565b60008082600f0b12613ceb57613c82613036858585600161497d565b613c9a613036858585600003600061497d565b613d06614e64565b6000613d128360801c90565b6040805160808101825286546001600160a01b0381168252600160a01b810460020b602083015262ffffff600160b81b82048116838501819052600160d01b9092049081166060840181905294955087949293600091610fff16613d769190615cc3565b9050603f600684901c166000613d916040610fff8616615cc3565b9050603f600685901c166000600f8a900b128015613db3575060008461ffff16115b15613ddf5761ffff8416613dc68a615a47565b613dd09190615d7d565b6001600160801b031660408b01525b600088600f0b128015613df6575060008361ffff16115b15613e225761ffff8316613e0989615a47565b613e139190615d7d565b6001600160801b031660608b01525b60008261ffff16118015613e3a575060008a60400151115b15613e6b578161ffff168a60400151613e539190615d04565b808b5260408b018051613e679083906157d4565b9052505b60008161ffff16118015613e83575060008a60600151115b15613eb8578061ffff168a60600151613e9c9190615d04565b60208b0181905260608b018051613eb49083906157d4565b9052505b50505050505050505092915050565b6000611565613ed68360801c90565b613ee08560801c90565b613eea9190615d18565b611d228486615d18565b60006401000276a36001600160a01b0383161080613f2f575073fffd8963efd1fc6a506488495d951d5263988d266001600160a01b03831610155b15613f4d5760405163015680db60e11b815260040160405180910390fd5b600160201b600160c01b03602083901b166001600160801b03811160071b81811c6001600160401b03811160061b90811c63ffffffff811160051b90811c61ffff811160041b90811c60ff8111600390811b91821c600f811160021b90811c918211600190811b92831c97908811961790941790921717909117171760808110613fdf57607f810383901c9150613fe9565b80607f0383901b91505b908002607f81811c60ff83811c9190911c800280831c81831c1c800280841c81841c1c800280851c81851c1c800280861c81861c1c800280871c81871c1c800280881c81881c1c800280891c81891c1c8002808a1c818a1c1c8002808b1c818b1c1c8002808c1c818c1c1c8002808d1c818d1c1c8002808e1c9c81901c9c909c1c80029c8d901c9e9d607f198f0160401b60c09190911c6001603f1b161760c19b909b1c6001603e1b169a909a1760c29990991c6001603d1b169890981760c39790971c6001603c1b169690961760c49590951c6001603b1b169490941760c59390931c6001603a1b169290921760c69190911c600160391b161760c79190911c600160381b161760c89190911c600160371b161760c99190911c600160361b161760ca9190911c600160351b161760cb9190911c600160341b161760cc9190911c600160331b161760cd9190911c600160321b1617693627a301d71055774c8581026f028f6481ab7f045a5af012a19d003aa9198101608090811d906fdb2df09e81959a81455e260799a0632f8301901d600281810b9083900b146141b757886001600160a01b031661419c8261394e565b6001600160a01b031611156141b157816141b9565b806141b9565b815b9998505050505050505050565b60408051600180825281830190925260609160009190602080830190803683370190505090508281600081518110614200576142006158e2565b602090810291909101015292915050565b505050505050565b6001600160a01b0384163b156142115760405163f23a6e6160e01b81526001600160a01b0385169063f23a6e619061425d9089908990889088908890600401615da3565b6020604051808303816000875af1925050508015614298575060408051601f3d908101601f19168201909252614295918101906158c5565b60015b614344576142a4615ddd565b806308c379a0036142dd57506142b8615df9565b806142c357506142df565b8060405162461bcd60e51b815260040161097c9190615056565b505b60405162461bcd60e51b815260206004820152603460248201527f455243313135353a207472616e7366657220746f206e6f6e2d455243313135356044820152732932b1b2b4bb32b91034b6b83632b6b2b73a32b960611b606482015260840161097c565b6001600160e01b0319811663f23a6e6160e01b146129205760405162461bcd60e51b815260206004820152602860248201527f455243313135353a204552433131353552656365697665722072656a656374656044820152676420746f6b656e7360c01b606482015260840161097c565b6001600160a01b0383166144175760405162461bcd60e51b815260206004820152602360248201527f455243313135353a206275726e2066726f6d20746865207a65726f206164647260448201526265737360e81b606482015260840161097c565b336000614423846141c6565b90506000614430846141c6565b6040805160208082018352600091829052888252600381528282206001600160a01b038b16835290522054909150848110156144ba5760405162461bcd60e51b8152602060048201526024808201527f455243313135353a206275726e20616d6f756e7420657863656564732062616c604482015263616e636560e01b606482015260840161097c565b60008681526003602090815260408083206001600160a01b03808c1680865291909352818420898603905590519091871690600080516020615ea383398151915290614509908b908b90615c85565b60405180910390a4604080516020810190915260009052612920565b612b52816149fb565b60008060008460020b8660020b8161454857614548615cad565b05905060008660020b12801561457557508460020b8660020b8161456e5761456e615cad565b0760020b15155b1561457f57600019015b83156145f257600080614591836148b4565b600182810b600090815260208d9052604090205460ff83169190911b800160001901908116801515975092945090925090856145d457888360ff168603026145e7565b886145de82614a1c565b840360ff168603025b965050505050614666565b600080614601836001016148b4565b600182810b600090815260208d9052604090205460ff83169190911b60001901199081168015159750929450909250908561464957888360ff0360ff1686600101010261465f565b888361465483614ab6565b0360ff168660010101025b9650505050505b5094509492505050565b60008080806001600160a01b03808916908a1610158187128015906146f55760006146a98989620f42400362ffffff16620f424061337e565b9050826146c2576146bd8c8c8c600161497d565b6146cf565b6146cf8b8d8c60016148c6565b95508581106146e0578a96506146ef565b6146ec8c8b8386614b9f565b96505b5061473f565b8161470c576147078b8b8b60006148c6565b614719565b6147198a8c8b600061497d565b935083886000031061472d5789955061473f565b61473c8b8a8a60000385614beb565b95505b6001600160a01b038a81169087161482156147a25780801561475e5750815b6147745761476f878d8c60016148c6565b614776565b855b9550808015614783575081155b61479957614794878d8c600061497d565b61479b565b845b94506147ec565b8080156147ac5750815b6147c2576147bd8c888c600161497d565b6147c4565b855b95508080156147d1575081155b6147e7576147e28c888c60006148c6565b6147e9565b845b94505b811580156147fc57508860000385115b15614808578860000394505b81801561482757508a6001600160a01b0316876001600160a01b031614155b15614836578589039350614853565b614850868962ffffff168a620f42400362ffffff16614c37565b93505b50505095509550955095915050565b60006001600160ff1b03821115611b2457600080fd5b600292830b600090815260049094016020526040909320600181018054909203909155908101805490920390915554600160801b9004600f0b90565b60020b600881901d9161010090910790565b6000836001600160a01b0316856001600160a01b031611156148e6579293925b600160601b600160e01b03606084901b166001600160a01b03868603811690871661491057600080fd5b8361494657866001600160a01b03166149338383896001600160a01b031661337e565b8161494057614940615cad565b04614972565b61497261495d8383896001600160a01b0316614c37565b886001600160a01b0316808204910615150190565b979650505050505050565b6000836001600160a01b0316856001600160a01b0316111561499d579293925b816149d1576149cc6001600160801b0384166149b98787615e82565b6001600160a01b0316600160601b61337e565b610cd7565b610cd76001600160801b0384166149e88787615e82565b6001600160a01b0316600160601b614c37565b60006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b6000808211614a2a57600080fd5b600160801b8210614a3d57608091821c91015b600160401b8210614a5057604091821c91015b600160201b8210614a6357602091821c91015b620100008210614a7557601091821c91015b6101008210614a8657600891821c91015b60108210614a9657600491821c91015b60048210614aa657600291821c91015b60028210611f3c57600101919050565b6000808211614ac457600080fd5b5060ff6001600160801b03821615614adf57607f1901614ae7565b608082901c91505b6001600160401b03821615614aff57603f1901614b07565b604082901c91505b63ffffffff821615614b1c57601f1901614b24565b602082901c91505b61ffff821615614b3757600f1901614b3f565b601082901c91505b60ff821615614b515760071901614b59565b600882901c91505b600f821615614b6b5760031901614b73565b600482901c91505b6003821615614b855760011901614b8d565b600282901c91505b6001821615611f3c5760001901919050565b600080856001600160a01b031611614bb657600080fd5b6000846001600160801b031611614bcc57600080fd5b81614bde576149cc8585856001614c77565b610cd78585856001614d5e565b600080856001600160a01b031611614c0257600080fd5b6000846001600160801b031611614c1857600080fd5b81614c2a576149cc8585856000614d5e565b610cd78585856000614c77565b6000614c4484848461337e565b905060008280614c5657614c56615cad565b8486091115611565576000198110614c6d57600080fd5b6001019392505050565b60008115614ce95760006001600160a01b03841115614cad57614ca884600160601b876001600160801b031661337e565b614cc4565b614cc46001600160801b038616606086901b615d04565b9050614ce1614cdc826001600160a01b038916615c72565b614e4e565b915050610a78565b60006001600160a01b03841115614d1757614d1284600160601b876001600160801b0316614c37565b614d34565b614d34606085901b6001600160801b038716808204910615150190565b905080866001600160a01b031611614d4b57600080fd5b614ce1816001600160a01b0388166157d4565b600082600003614d6f575083610a78565b600160601b600160e01b03606085901b168215614e01576001600160a01b03861684810290858281614da357614da3615cad565b0403614dd357818101828110614dd157614dc783896001600160a01b031683614c37565b9350505050610a78565b505b50614ce18185614dec6001600160a01b038a1683615d04565b614df69190615c72565b808204910615150190565b6001600160a01b03861684810290858281614e1e57614e1e615cad565b04148015614e2b57508082115b614e3457600080fd5b808203614dc7614cdc846001600160a01b038b1684614c37565b806001600160a01b0381168114611f3c57600080fd5b6040518060800160405280600081526020016000815260200160008152602001600081525090565b6040518060c00160405280600081526020016000815260200160006001600160a01b03168152602001600060020b81526020016000815260200160006001600160801b031681525090565b6001600160a01b0381168114612b5257600080fd5b60008060408385031215614eff57600080fd5b8235614f0a81614ed7565b946020939093013593505050565b6001600160e01b031981168114612b5257600080fd5b600060208284031215614f4057600080fd5b813561156581614f18565b8035600281900b8114611f3c57600080fd5b60008060008060808587031215614f7357600080fd5b843593506020850135614f8581614ed7565b9250614f9360408601614f4b565b9150614fa160608601614f4b565b905092959194509250565b600080600060608486031215614fc157600080fd5b8335614fcc81614ed7565b92506020840135614fdc81614ed7565b929592945050506040919091013590565b600060208284031215614fff57600080fd5b5035919050565b60005b83811015615021578181015183820152602001615009565b50506000910152565b60008151808452615042816020860160208601615006565b601f01601f19169290920160200192915050565b602081526000611565602083018461502a565b634e487b7160e01b600052604160045260246000fd5b606081016001600160401b038111828210171561509e5761509e615069565b60405250565b601f8201601f191681016001600160401b03811182821017156150c9576150c9615069565b6040525050565b62ffffff81168114612b5257600080fd5b600060a082840312156150f357600080fd5b60405160a081016001600160401b038111828210171561511557615115615069565b604052905080823561512681614ed7565b8152602083013561513681614ed7565b60208201526040830135615149816150d0565b604082015261515a60608401614f4b565b6060820152608083013561516d81614ed7565b6080919091015292915050565b60008083601f84011261518c57600080fd5b5081356001600160401b038111156151a357600080fd5b6020830191508360208285010111156151bb57600080fd5b9250929050565b600080600080600061010086880312156151db57600080fd5b6151e587876150e1565b945060a0860135935060c0860135925060e08601356001600160401b0381111561520e57600080fd5b61521a8882890161517a565b969995985093965092949392505050565b600060a0828403121561523d57600080fd5b61156583836150e1565b60006020828403121561525957600080fd5b813561156581614ed7565b60006001600160401b0382111561527d5761527d615069565b5060051b60200190565b600082601f83011261529857600080fd5b813560206152a582615264565b6040516152b282826150a4565b83815260059390931b85018201928281019150868411156152d257600080fd5b8286015b848110156152ed57803583529183019183016152d6565b509695505050505050565b6000806040838503121561530b57600080fd5b82356001600160401b038082111561532257600080fd5b818501915085601f83011261533657600080fd5b8135602061534382615264565b60405161535082826150a4565b83815260059390931b850182019282810191508984111561537057600080fd5b948201945b8386101561539757853561538881614ed7565b82529482019490820190615375565b965050860135925050808211156153ad57600080fd5b506153ba85828601615287565b9150509250929050565b6020808252825182820181905260009190848201906040850190845b818110156153fc578351835292840192918401916001016153e0565b50909695505050505050565b60029190910b815260200190565b60008060008084860361012081121561542e57600080fd5b61543887876150e1565b94506060609f198201121561544c57600080fd5b506040516154598161507f565b61546560a08701614f4b565b815261547360c08701614f4b565b602082015260e0860135604082015292506101008501356001600160401b0381111561549e57600080fd5b6154aa8782880161517a565b95989497509550505050565b60008060008060e085870312156154cc57600080fd5b6154d686866150e1565b935060a08501356154e681614ed7565b925060c08501356001600160401b0381111561549e57600080fd5b6000806020838503121561551457600080fd5b82356001600160401b0381111561552a57600080fd5b6155368582860161517a565b90969095509350505050565b80358015158114611f3c57600080fd5b6000806040838503121561556557600080fd5b823561557081614ed7565b915061557e60208401615542565b90509250929050565b6000806040838503121561559a57600080fd5b82356155a581614ed7565b915060208301356155b581614ed7565b809150509250929050565b6001600160a01b0391909116815260200190565b60008060008060008060a087890312156155ed57600080fd5b86356155f881614ed7565b9550602087013561560881614ed7565b9450604087013593506060870135925060808701356001600160401b0381111561563157600080fd5b61563d89828a0161517a565b979a9699509497509295939492505050565b60006001600160401b0382111561566857615668615069565b50601f01601f191660200190565b600080600080600060a0868803121561568e57600080fd5b853561569981614ed7565b945060208601356156a981614ed7565b9350604086013592506060860135915060808601356001600160401b038111156156d257600080fd5b8601601f810188136156e357600080fd5b80356156ee8161564f565b6040516156fb82826150a4565b8281528a602084860101111561571057600080fd5b82602085016020830137600060208483010152809450505050509295509295909350565b60008060008084860361012081121561574c57600080fd5b61575687876150e1565b94506060609f198201121561576a57600080fd5b506040516157778161507f565b61578360a08701615542565b815260c0860135602082015260e086013561579d81614ed7565b604082015292506101008501356001600160401b0381111561549e57600080fd5b634e487b7160e01b600052601160045260246000fd5b818103818111156109aa576109aa6157be565b600181811c908216806157fb57607f821691505b6020821081036113d457634e487b7160e01b600052602260045260246000fd5b80516001600160a01b03908116835260208083015182169084015260408083015162ffffff169084015260608083015160020b9084015260809182015116910152565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6001600160a01b038716815260006101206158a5602084018961581b565b8660c08401528560e0840152806101008401526141b9818401858761585e565b6000602082840312156158d757600080fd5b815161156581614f18565b634e487b7160e01b600052603260045260246000fd5b60006001820161590a5761590a6157be565b5060010190565b805160020b8252602081015160020b6020830152604081015160408301525050565b6001600160a01b03861681526000610140615951602084018861581b565b61595e60c0840187615911565b80610120840152615972818401858761585e565b98975050505050505050565b6001600160a01b0387168152600061016061599c602084018961581b565b6159a960c0840188615911565b85610120840152806101408401526141b9818401858761585e565b6001600160a01b038681168252600090610100906159e5602085018961581b565b861660c084015260e08301819052615972818401858761585e565b6001600160a01b03878116825260009061012090615a21602085018a61581b565b80881660c0850152508560020b60e0840152806101008401526141b9818401858761585e565b6000600f82900b6001607f1b8101615a6157615a616157be565b60000392915050565b602081526000610a7860208301848661585e565b600060208284031215615a9057600080fd5b81516001600160401b03811115615aa657600080fd5b8201601f81018413615ab757600080fd5b8051615ac28161564f565b604051615acf82826150a4565b828152866020848601011115615ae457600080fd5b615af5836020830160208701615006565b9695505050505050565b805115158252602080820151908301526040908101516001600160a01b0316910152565b6001600160a01b03861681526000610140615b41602084018861581b565b61595e60c0840187615aff565b600060208284031215615b6057600080fd5b8151611565816150d0565b6001600160a01b03871681526000610160615b89602084018961581b565b6159a960c0840188615aff565b8082018281126000831280158216821582161715615bb657615bb66157be565b505092915050565b60a081016109aa828461581b565b60008160020b627fffff198103615a6157615a616157be565b6001600160801b03818116838216019080821115615c0557615c056157be565b5092915050565b6001600160801b03828116828216039080821115615c0557615c056157be565b600f81810b9083900b0160016001607f1b03811360016001607f1b0319821217156109aa576109aa6157be565b600060208284031215615c6b57600080fd5b5051919050565b808201808211156109aa576109aa6157be565b918252602082015260400190565b6001600160a01b0392831681529116602082015260400190565b634e487b7160e01b600052601260045260246000fd5b600061ffff80841680615cd857615cd8615cad565b92169190910692915050565b8181036000831280158383131683831282161715615c0557615c056157be565b600082615d1357615d13615cad565b500490565b600f82810b9082900b0360016001607f1b0319811260016001607f1b03821317156109aa576109aa6157be565b608081526000615d58608083018761502a565b6001600160a01b03959095166020830152506040810192909252606090910152919050565b60006001600160801b0383811680615d9757615d97615cad565b92169190910492915050565b6001600160a01b03868116825285166020820152604081018490526060810183905260a0608082018190526000906149729083018461502a565b600060033d1115615df65760046000803e5060005160e01c5b90565b600060443d1015615e075790565b6040516003193d81016004833e81513d6001600160401b038083116024840183101715615e3657505050505090565b8285019150815181811115615e4e5750505050505090565b843d8701016020828501011115615e685750505050505090565b615e77602082860101876150a4565b509095945050505050565b6001600160a01b03828116828216039080821115615c0557615c056157be56fec3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62760a9a962ae3d184e99c0483cf5684fb3170f47116ca4f445c50209da4f4f906a264697066735822122089418c4eb0cdd0285ac4648f2de407dc7fd03db4664ccdc8956f0008ec8db92d64736f6c63430008140033",
  "devdoc": {
    "errors": {
      "PriceLimitAlreadyExceeded(uint160,uint160)": [
        {
          "params": {
            "sqrtPriceCurrentX96": "The invalid, already surpassed sqrtPriceLimitX96",
            "sqrtPriceLimitX96": "The surpassed price limit"
          }
        }
      ],
      "PriceLimitOutOfBounds(uint160)": [
        {
          "params": {
            "sqrtPriceLimitX96": "The invalid, out-of-bounds sqrtPriceLimitX96"
          }
        }
      ],
      "TickLowerOutOfBounds(int24)": [
        {
          "params": {
            "tickLower": "The invalid tickLower"
          }
        }
      ],
      "TickMisaligned(int24,int24)": [
        {
          "params": {
            "tick": "the invalid tick",
            "tickSpacing": "The tick spacing of the pool"
          }
        }
      ],
      "TickUpperOutOfBounds(int24)": [
        {
          "params": {
            "tickUpper": "The invalid tickUpper"
          }
        }
      ],
      "TicksMisordered(int24,int24)": [
        {
          "params": {
            "tickLower": "The invalid tickLower",
            "tickUpper": "The invalid tickUpper"
          }
        }
      ]
    },
    "events": {
      "ApprovalForAll(address,address,bool)": {
        "details": "Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to `approved`."
      },
      "TransferBatch(address,address,address,uint256[],uint256[])": {
        "details": "Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all transfers."
      },
      "TransferSingle(address,address,address,uint256,uint256)": {
        "details": "Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`."
      },
      "URI(string,uint256)": {
        "details": "Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI. If an {URI} event was emitted for `id`, the standard https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value returned by {IERC1155MetadataURI-uri}."
      }
    },
    "kind": "dev",
    "methods": {
      "balanceOf(address,uint256)": {
        "details": "See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address."
      },
      "balanceOfBatch(address[],uint256[])": {
        "details": "See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length."
      },
      "extsload(bytes32)": {
        "params": {
          "slot": "Key of slot to sload"
        },
        "returns": {
          "value": "The value of the slot as bytes32"
        }
      },
      "isApprovedForAll(address,address)": {
        "details": "See {IERC1155-isApprovedForAll}."
      },
      "lock(bytes)": {
        "params": {
          "data": "Any data to pass to the callback, via `ILockCallback(msg.sender).lockCallback(data)`"
        },
        "returns": {
          "result": "The data returned by the call to `ILockCallback(msg.sender).lockCallback(data)`"
        }
      },
      "safeTransferFrom(address,address,uint256,uint256,bytes)": {
        "details": "See {IERC1155-safeTransferFrom}."
      },
      "setApprovalForAll(address,bool)": {
        "details": "See {IERC1155-setApprovalForAll}."
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      },
      "take(address,address,uint256)": {
        "details": "Can also be used as a mechanism for _free_ flash loans"
      },
      "uri(uint256)": {
        "details": "See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\\{id\\}` substring with the actual token type ID."
      }
    },
    "stateVariables": {
      "currencyDelta": {
        "details": "Represents the currencies due/owed to each locker. Must all net to zero when the last lock is released."
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "CannotUpdateEmptyPosition()": [
        {
          "notice": "Cannot update a position with no liquidity"
        }
      ],
      "ERC20TransferFailed()": [
        {
          "notice": "Thrown when an ERC20 transfer fails"
        }
      ],
      "InvalidHookResponse()": [
        {
          "notice": "Hook did not return its selector"
        }
      ],
      "InvalidSqrtRatio()": [
        {
          "notice": "Thrown when the ratio passed to #getTickAtSqrtRatio does not correspond to a price between MIN_TICK and MAX_TICK"
        }
      ],
      "InvalidTick()": [
        {
          "notice": "Thrown when the tick passed to #getSqrtRatioAtTick is not between MIN_TICK and MAX_TICK"
        }
      ],
      "NativeTransferFailed()": [
        {
          "notice": "Thrown when a native transfer fails"
        }
      ],
      "NoLiquidityToReceiveFees()": [
        {
          "notice": "Thrown by donate if there is currently 0 liquidity, since the fees will not go to any liquidity providers"
        }
      ],
      "PoolAlreadyInitialized()": [
        {
          "notice": "Thrown when trying to initalize an already initialized pool"
        }
      ],
      "PoolNotInitialized()": [
        {
          "notice": "Thrown when trying to interact with a non-initialized pool"
        }
      ],
      "PriceLimitAlreadyExceeded(uint160,uint160)": [
        {
          "notice": "Thrown when sqrtPriceLimitX96 on a swap has already exceeded its limit"
        }
      ],
      "PriceLimitOutOfBounds(uint160)": [
        {
          "notice": "Thrown when sqrtPriceLimitX96 lies outside of valid tick/price range"
        }
      ],
      "SwapAmountCannotBeZero()": [
        {
          "notice": "Thrown when trying to swap amount of 0"
        }
      ],
      "TickLiquidityOverflow(int24)": [
        {
          "notice": "For the tick spacing, the tick has too much liquidity"
        }
      ],
      "TickLowerOutOfBounds(int24)": [
        {
          "notice": "Thrown when tickLower is less than min tick"
        }
      ],
      "TickMisaligned(int24,int24)": [
        {
          "notice": "Thrown when the tick is not enumerated by the tick spacing"
        }
      ],
      "TickUpperOutOfBounds(int24)": [
        {
          "notice": "Thrown when tickUpper exceeds max tick"
        }
      ],
      "TicksMisordered(int24,int24)": [
        {
          "notice": "Thrown when tickLower is not below tickUpper"
        }
      ]
    },
    "kind": "user",
    "methods": {
      "MAX_TICK_SPACING()": {
        "notice": "Returns the constant representing the maximum tickSpacing for an initialized pool key"
      },
      "MIN_PROTOCOL_FEE_DENOMINATOR()": {
        "notice": "Returns the minimum denominator for the protocol fee, which restricts it to a maximum of 25%"
      },
      "donate((address,address,uint24,int24,address),uint256,uint256,bytes)": {
        "notice": "Donate the given currency amounts to the pool with the given pool key"
      },
      "extsload(bytes32)": {
        "notice": "Called by external contracts to access granular pool state"
      },
      "getLiquidity(bytes32)": {
        "notice": "Get the current value of liquidity of the given pool"
      },
      "getLiquidity(bytes32,address,int24,int24)": {
        "notice": "Get the current value of liquidity for the specified pool and position"
      },
      "getLock(uint256)": {
        "notice": "Returns the locker in the ith position of the locker queue."
      },
      "getPosition(bytes32,address,int24,int24)": {
        "notice": "Get the position struct for a specified pool and position"
      },
      "getSlot0(bytes32)": {
        "notice": "Get the current value in slot0 of the given pool"
      },
      "hookFeesAccrued(address,address)": {
        "notice": "Given a hook and a currency address, returns the fees accrued"
      },
      "initialize((address,address,uint24,int24,address),uint160,bytes)": {
        "notice": "Initialize the state for a given pool ID"
      },
      "lock(bytes)": {
        "notice": "All operations go through this function"
      },
      "lockData()": {
        "notice": "Returns lock data"
      },
      "mint(address,address,uint256)": {
        "notice": "Called by the user to move value into ERC1155 balance"
      },
      "modifyPosition((address,address,uint24,int24,address),(int24,int24,int256),bytes)": {
        "notice": "Modify the position for the given pool"
      },
      "protocolFeesAccrued(address)": {
        "notice": "Given a currency address, returns the protocol fees accrued in that currency"
      },
      "reservesOf(address)": {
        "notice": "Returns the reserves for a given ERC20 currency"
      },
      "setHookFees((address,address,uint24,int24,address))": {
        "notice": "Sets the hook's swap and withdrawal fees for the given pool"
      },
      "setProtocolFees((address,address,uint24,int24,address))": {
        "notice": "Sets the protocol's swap and withdrawal fees for the given pool Protocol fees are always a portion of a fee that is owed. If that underlying fee is 0, no protocol fees will accrue even if it is set to > 0."
      },
      "settle(address)": {
        "notice": "Called by the user to pay what is owed"
      },
      "swap((address,address,uint24,int24,address),(bool,int256,uint160),bytes)": {
        "notice": "Swap against the given pool"
      },
      "take(address,address,uint256)": {
        "notice": "Called by the user to net out some value owed to the user"
      }
    },
    "notice": "Holds the state for all pools",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3660,
        "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
        "label": "protocolFeesAccrued",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_userDefinedValueType(Currency)11044,t_uint256)"
      },
      {
        "astId": 3667,
        "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
        "label": "hookFeesAccrued",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_mapping(t_userDefinedValueType(Currency)11044,t_uint256))"
      },
      {
        "astId": 3670,
        "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
        "label": "protocolFeeController",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(IProtocolFeeController)5778"
      },
      {
        "astId": 77,
        "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
        "label": "_balances",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_uint256,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 83,
        "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
        "label": "_operatorApprovals",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 85,
        "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
        "label": "_uri",
        "offset": 0,
        "slot": "5",
        "type": "t_string_storage"
      },
      {
        "astId": 4146,
        "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
        "label": "lockData",
        "offset": 0,
        "slot": "6",
        "type": "t_struct(LockData)5602_storage"
      },
      {
        "astId": 4154,
        "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
        "label": "currencyDelta",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_address,t_mapping(t_userDefinedValueType(Currency)11044,t_int256))"
      },
      {
        "astId": 4161,
        "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
        "label": "reservesOf",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_userDefinedValueType(Currency)11044,t_uint256)"
      },
      {
        "astId": 4167,
        "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
        "label": "pools",
        "offset": 0,
        "slot": "9",
        "type": "t_mapping(t_userDefinedValueType(PoolId)11298,t_struct(State)7141_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IProtocolFeeController)5778": {
        "encoding": "inplace",
        "label": "contract IProtocolFeeController",
        "numberOfBytes": "20"
      },
      "t_int128": {
        "encoding": "inplace",
        "label": "int128",
        "numberOfBytes": "16"
      },
      "t_int16": {
        "encoding": "inplace",
        "label": "int16",
        "numberOfBytes": "2"
      },
      "t_int24": {
        "encoding": "inplace",
        "label": "int24",
        "numberOfBytes": "3"
      },
      "t_int256": {
        "encoding": "inplace",
        "label": "int256",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_mapping(t_userDefinedValueType(Currency)11044,t_int256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(Currency => int256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_userDefinedValueType(Currency)11044,t_int256)"
      },
      "t_mapping(t_address,t_mapping(t_userDefinedValueType(Currency)11044,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(Currency => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_userDefinedValueType(Currency)11044,t_uint256)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_bytes32,t_struct(Info)8995_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct Position.Info)",
        "numberOfBytes": "32",
        "value": "t_struct(Info)8995_storage"
      },
      "t_mapping(t_int16,t_uint256)": {
        "encoding": "mapping",
        "key": "t_int16",
        "label": "mapping(int16 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_int24,t_struct(TickInfo)7116_storage)": {
        "encoding": "mapping",
        "key": "t_int24",
        "label": "mapping(int24 => struct Pool.TickInfo)",
        "numberOfBytes": "32",
        "value": "t_struct(TickInfo)7116_storage"
      },
      "t_mapping(t_uint256,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_userDefinedValueType(Currency)11044,t_int256)": {
        "encoding": "mapping",
        "key": "t_userDefinedValueType(Currency)11044",
        "label": "mapping(Currency => int256)",
        "numberOfBytes": "32",
        "value": "t_int256"
      },
      "t_mapping(t_userDefinedValueType(Currency)11044,t_uint256)": {
        "encoding": "mapping",
        "key": "t_userDefinedValueType(Currency)11044",
        "label": "mapping(Currency => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_userDefinedValueType(PoolId)11298,t_struct(State)7141_storage)": {
        "encoding": "mapping",
        "key": "t_userDefinedValueType(PoolId)11298",
        "label": "mapping(PoolId => struct Pool.State)",
        "numberOfBytes": "32",
        "value": "t_struct(State)7141_storage"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(Info)8995_storage": {
        "encoding": "inplace",
        "label": "struct Position.Info",
        "members": [
          {
            "astId": 8990,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "liquidity",
            "offset": 0,
            "slot": "0",
            "type": "t_uint128"
          },
          {
            "astId": 8992,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "feeGrowthInside0LastX128",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 8994,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "feeGrowthInside1LastX128",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(LockData)5602_storage": {
        "encoding": "inplace",
        "label": "struct IPoolManager.LockData",
        "members": [
          {
            "astId": 5598,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "length",
            "offset": 0,
            "slot": "0",
            "type": "t_uint128"
          },
          {
            "astId": 5601,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "nonzeroDeltaCount",
            "offset": 16,
            "slot": "0",
            "type": "t_uint128"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Slot0)7107_storage": {
        "encoding": "inplace",
        "label": "struct Pool.Slot0",
        "members": [
          {
            "astId": 7100,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "sqrtPriceX96",
            "offset": 0,
            "slot": "0",
            "type": "t_uint160"
          },
          {
            "astId": 7102,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "tick",
            "offset": 20,
            "slot": "0",
            "type": "t_int24"
          },
          {
            "astId": 7104,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "protocolFees",
            "offset": 23,
            "slot": "0",
            "type": "t_uint24"
          },
          {
            "astId": 7106,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "hookFees",
            "offset": 26,
            "slot": "0",
            "type": "t_uint24"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(State)7141_storage": {
        "encoding": "inplace",
        "label": "struct Pool.State",
        "members": [
          {
            "astId": 7120,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "slot0",
            "offset": 0,
            "slot": "0",
            "type": "t_struct(Slot0)7107_storage"
          },
          {
            "astId": 7122,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "feeGrowthGlobal0X128",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 7124,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "feeGrowthGlobal1X128",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 7126,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "liquidity",
            "offset": 0,
            "slot": "3",
            "type": "t_uint128"
          },
          {
            "astId": 7131,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "ticks",
            "offset": 0,
            "slot": "4",
            "type": "t_mapping(t_int24,t_struct(TickInfo)7116_storage)"
          },
          {
            "astId": 7135,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "tickBitmap",
            "offset": 0,
            "slot": "5",
            "type": "t_mapping(t_int16,t_uint256)"
          },
          {
            "astId": 7140,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "positions",
            "offset": 0,
            "slot": "6",
            "type": "t_mapping(t_bytes32,t_struct(Info)8995_storage)"
          }
        ],
        "numberOfBytes": "224"
      },
      "t_struct(TickInfo)7116_storage": {
        "encoding": "inplace",
        "label": "struct Pool.TickInfo",
        "members": [
          {
            "astId": 7109,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "liquidityGross",
            "offset": 0,
            "slot": "0",
            "type": "t_uint128"
          },
          {
            "astId": 7111,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "liquidityNet",
            "offset": 16,
            "slot": "0",
            "type": "t_int128"
          },
          {
            "astId": 7113,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "feeGrowthOutside0X128",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 7115,
            "contract": "@uniswap/v4-core/contracts/PoolManager.sol:PoolManager",
            "label": "feeGrowthOutside1X128",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint160": {
        "encoding": "inplace",
        "label": "uint160",
        "numberOfBytes": "20"
      },
      "t_uint24": {
        "encoding": "inplace",
        "label": "uint24",
        "numberOfBytes": "3"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_userDefinedValueType(Currency)11044": {
        "encoding": "inplace",
        "label": "Currency",
        "numberOfBytes": "20"
      },
      "t_userDefinedValueType(PoolId)11298": {
        "encoding": "inplace",
        "label": "PoolId",
        "numberOfBytes": "32"
      }
    }
  }
}